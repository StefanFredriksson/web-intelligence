Offbyone error An offbyone error OBOE or OBOB offbyone bug or OB1 error is a logic error involving the discrete equivalent of a boundary condition It often occurs in computer programming when an iterative loop iterates one time too many or too few This problem could arise when a programmer makes mistakes such as using is less than or equal to where is less than should have been used in a comparison or fails to take into account that a sequence starts at zero rather than one as with array indices in many languages This can also occur in a mathematical context Contents 1 Looping over arrays 2 Fencepost error 3 Security implications 4 See also 5 References Looping over arrays edit Consider an array of items and items m through n inclusive are to be processed How many items are there An intuitive answer may be n m but that is off by one exhibiting a fencepost error the correct answer is n m 1 For this reason ranges in computing are often represented by halfopen intervals the range from m to n inclusive is represented by the range from m inclusive to n 1 exclusive to avoid fencepost errors For example a loop that iterates five times from 0 to 4 inclusive can be written as a halfopen interval from 0 to5 for index 0 index 5 index Body of the loop The loop body is executed first of all with index equal to 0 i then becomes 1 2 3 and finally 4 on successive iterations At that point index becomes 5 so index 5 is false and the loop ends However if the comparison used were less than or equal to the loop would be carried out six times index takes the values 0 1 2 3 4 and 5 Likewise if index were initialized to 1 rather than 0 there would only be four iterations index takes the values 1 2 3 and 4 Both of these alternatives can cause offbyone errors Another such error can occur if a dowhile loop is used in place of a while loop or vice versa A dowhile loop is guaranteed to run at least once Arrayrelated confusion may also result from differences in programming languages Numbering from 0 is most common but some languages start array numbering with 1 Pascal has arrays with userdefined indices This makes it possible to model the array indices after the problem domain Fencepost error edit A straight fence with n sections has n1 posts A fencepost error occasionally called a telegraph pole lamppost or picket fence error is a specific type of offbyone error An early description of this error appears in the works of Vitruvius 1 The following problem illustrates the error mwparseroutput templatequoteoverflowhiddenmargin1em 0padding0 40pxmwparseroutput templatequote templatequotecitelineheight15emtextalignleftpaddingleft16emmargintop0 If you build a straight fence 30 meters long with posts spaced 3 meters apart how many posts do you need The naive answer 10 is wrong The fence has 10 sections but 11 posts The reverse error occurs when the number of posts is known and the number of sections is assumed to be the same The actual number of sections is one less than the number of posts More generally the problem can be stated as follows If you have n posts how many sections are there between them The correct answer may be n 1 if the line of posts is openended n if they form a loop or n 1 if the posts do not occur at the end of the fence for instance if the fence runs between two walls The precise problem definition must be carefully considered as the setup for one situation may give the wrong answer for other situations Fencepost errors come from counting things rather than the spaces between them or vice versa or by neglecting to consider whether one should count one or both ends of a row Fencepost errors can also occur in units other than length For example the Time Pyramid consisting of 120 blocks placed at 10year intervals between blocks is scheduled to take 1190 years to build not 1200 from the installation of the first block to the last block One of the earliest fencepost errors involved time where the Julian calendar originally calculated leap years incorrectly due to counting inclusively rather than exclusively yielding a leap year every three years rather than every four Fencepost error can citation needed in rare occasions refer to an error induced by unexpected regularities in input values which can for instance completely thwart a theoretically efficient binary tree or hash function implementation This error involves the difference between expected and worst case behaviours of an algorithm In larger numbers being off by one is often not a major issue In smaller numbers however and specific cases where accuracy is paramount committing an offbyone error can be disastrous Sometimes such an issue will also be repeated and therefore worsened by someone passing on an incorrect calculation if the following person makes the same kind of mistake again of course the error might also be reversed An example of this error can occur in the computational language MATLAB with the linspace linear interpolation function whose parameters are lower value upper value number of values and not lower value upper value number of increments A programmer who misunderstands the third parameter to be the number of increments might hope that linspace0105 would achieve a sequence 0 2 4 6 8 10 but instead would get 0 25 5 75 10 Security implications edit A common offbyone error which results in a securityrelated bug is caused by misuse of the C standard library strncat routine A common misconception with strncat is that the guaranteed null termination will not write beyond the maximum length In reality it will write a terminating null character one byte beyond the maximum length specified The following code contains such a bug void foo char s char buf 15 memset buf 0 sizeof buf strncat buf s sizeof buf Final parameter should be sizeofbuf1 Offbyone errors are common in using the C library because it is not consistent with respect to whether one needs to subtract 1 byte functions like fgets and strncpy will never write past the length given them fgets subtracts 1 itself and only retrieves length1 bytes whereas others like strncat will write past the length given them So the programmer has to remember for which functions they need to subtract 1 On some systems little endian architectures in particular this can result in the overwriting of the least significant byte of the frame pointer This can cause an exploitable condition where an attacker can hijack the local variables for the calling routine One approach that often helps avoid such problems is to use variants of these functions that calculate how much to write based on the total length of the buffer rather than the maximum number of characters to write Such functions include strlcat and strlcpy and are often considered safer because they make it easier to avoid accidentally writing past the end of a buffer In the code example above calling strlcatbuf s sizeofbuf instead would remove the bug See also edit Boundaryvalue analysis Pigeonhole principle Rounding error Zerobased numbering References edit Moniot Robert K Who first described the fencepost error Fordham University archived from the original on 20160305 retrieved 20160707 mwparseroutput citecitationfontstyleinheritmwparseroutput citation qquotesmwparseroutput citation cs1lockfree abackgroundurluploadwikimediaorgwikipediacommonsthumb665Lockgreensvg9pxLockgreensvgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locklimited amwparseroutput citation cs1lockregistration abackgroundurluploadwikimediaorgwikipediacommonsthumbdd6Lockgrayalt2svg9pxLockgrayalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locksubscription abackgroundurluploadwikimediaorgwikipediacommonsthumbaaaLockredalt2svg9pxLockredalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput cs1subscriptionmwparseroutput cs1registrationcolor555mwparseroutput cs1subscription spanmwparseroutput cs1registration spanborderbottom1px dottedcursorhelpmwparseroutput cs1wsicon abackgroundurluploadwikimediaorgwikipediacommonsthumb44cWikisourcelogosvg12pxWikisourcelogosvgpngnorepeatbackgroundpositionright 1em centermwparseroutput codecs1codecolorinheritbackgroundinheritborderinheritpaddinginheritmwparseroutput cs1hiddenerrordisplaynonefontsize100mwparseroutput cs1visibleerrorfontsize100mwparseroutput cs1maintdisplaynonecolor33aa33marginleft03emmwparseroutput cs1subscriptionmwparseroutput cs1registrationmwparseroutput cs1formatfontsize95mwparseroutput cs1kernleftmwparseroutput cs1kernwlleftpaddingleft02emmwparseroutput cs1kernrightmwparseroutput cs1kernwlrightpaddingright02em An earlier version of this article was based on fencepost error at FOLDOC used with permission Dijkstra Edsger Wybe May 2 2008 Why numbering should start at zero EWD 831 E W Dijkstra Archive University of Texas at Austin Retrieved 20110316