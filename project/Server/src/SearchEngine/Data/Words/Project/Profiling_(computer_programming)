Profiling computer programming This article needs additional citations for verification Please help improve this article by adding citations to reliable sources Unsourced material may be challenged and removed Find sources Profilingcomputer programming news newspapers books scholar JSTOR January 2009 Learn how and when to remove this template message Program execution General concepts Code Translation Compiler Compiletime Optimizing compiler Intermediate representation IR Execution Runtime system Runtime Executable Interpreter Virtual machine Types of code Source code Object code Bytecode Machine code Microcode Compilation strategies Justintime JIT Tracing justintime Aheadoftime AOT Transcompilation Recompilation Notable runtimes Android Runtime ART Common Language Runtime CLR Mono crt0 HHVM Java virtual machine JVM ObjectiveC V8 Nodejs PyPy Zend Engine Notable compilers toolchains GNU Compiler Collection GCC LLVM Clang v t e In software engineering profiling program profiling software profiling is a form of dynamic program analysis that measures for example the space memory or time complexity of a program the usage of particular instructions or the frequency and duration of function calls Most commonly profiling information serves to aid program optimization Profiling is achieved by instrumenting either the program source code or its binary executable form using a tool called a profiler or code profiler Profilers may use a number of different techniques such as eventbased statistical instrumented and simulation methods Contents 1 Gathering program events 2 Use of profilers 3 History 4 Profiler types based on output 41 Flat profiler 42 Callgraph profiler 43 Inputsensitive profiler 5 Data granularity in profiler types 51 Eventbased profilers 52 Statistical profilers 53 Instrumentation 54 Interpreter instrumentation 55 HypervisorSimulator 6 See also 7 References 8 External links Gathering program events edit Profilers use a wide variety of techniques to collect data including hardware interrupts code instrumentation instruction set simulation operating system hooks and performance counters Profilers are used in the performance engineering process Use of profilers edit Graphical output of the CodeAnalyst profiler mwparseroutput templatequoteoverflowhiddenmargin1em 0padding0 40pxmwparseroutput templatequote templatequotecitelineheight15emtextalignleftpaddingleft16emmargintop0 Program analysis tools are extremely important for understanding program behavior Computer architects need such tools to evaluate how well programs will perform on new architectures Software writers need tools to analyze their programs and identify critical sections of code Compiler writers often use such tools to find out how well their instruction scheduling or branch prediction algorithm is performing ATOM PLDI 94 The output of a profiler may be A statistical summary of the events observed a profile Summary profile information is often shown annotated against the source code statements where the events occur so the size of measurement data is linear to the code size of the program source count 0001 IF X A 00550002 THEN DO 0003 ADD 1 to XCOUNT 00320004 ELSE0005 IF X B 0055 A stream of recorded events a trace For sequential programs a summary profile is usually sufficient but performance problems in parallel programs waiting for messages or synchronization issues often depend on the time relationship of events thus requiring a full trace to get an understanding of what is happening The size of a full trace is linear to the programs instruction path length making it somewhat impractical A trace may therefore be initiated at one point in a program and terminated at another point to limit the output An ongoing interaction with the hypervisor continuous or periodic monitoring via onscreen display for instance This provides the opportunity to switch a trace on or off at any desired point during execution in addition to viewing ongoing metrics about the still executing program It also provides the opportunity to suspend asynchronous processes at critical points to examine interactions with other parallel processes in more detail A profiler can be applied to an individual method or at the scale of a module or program to identify performance bottlenecks by making longrunning code obvious 1 A profiler can be used to understand code from a timing point of view with the objective of optimizing it to handle various runtime conditions 2 or various loads 3 Profiling results can be ingested by a compiler that provides profileguided optimization 4 Profiling results can be used to guide the design and optimization of an individual algorithm the Krauss matching wildcards algorithm is an example 5 Profilers are built into some application performance management systems that aggregate profiling data to provide insight into transaction workloads in distributed applications 6 History edit Performanceanalysis tools existed on IBM360 and IBM370 platforms from the early 1970s usually based on timer interrupts which recorded the Program status word PSW at set timerintervals to detect hot spots in executing code citation needed This was an early example of sampling see below In early 1974 instructionset simulators permitted full trace and other performancemonitoring features citation needed Profilerdriven program analysis on Unix dates back to 1973 7 when Unix systems included a basic tool prof which listed each function and how much of program execution time it used In 1982 gprof extended the concept to a complete call graph analysis 8 In 1994 Amitabh Srivastava and Alan Eustace of Digital Equipment Corporation published a paper describing ATOM 9 Analysis Tools with OM The ATOM platform converts a program into its own profiler at compile time it inserts code into the program to be analyzed That inserted code outputs analysis data This technique modifying a program to analyze itself is known as instrumentation In 2004 both the gprof and ATOM papers appeared on the list of the 50 most influential PLDI papers for the 20year period ending in 1999 10 Profiler types based on output edit Flat profiler edit Flat profilers compute the average call times from the calls and do not break down the call times based on the callee or the context Callgraph profiler edit Call graph profilers 8 show the call times and frequencies of the functions and also the callchains involved based on the callee In some tools full context is not preserved Inputsensitive profiler edit Inputsensitive profilers 11 12 13 add a further dimension to flat or callgraph profilers by relating performance measures to features of the input workloads such as input size or input values They generate charts that characterize how an applications performance scales as a function of its input Data granularity in profiler types edit Profilers which are also programs themselves analyze target programs by collecting information on their execution Based on their data granularity on how profilers collect information they are classified into event based or statistical profilers Profilers interrupt program execution to collect information which may result in a limited resolution in the time measurements which should be taken with a grain of salt Basic block profilers report a number of machine clock cycles devoted to executing each line of code or a timing based on adding these together the timings reported per basic block may not reflect a difference between cache hits and misses 14 15 Eventbased profilers edit The programming languages listed here have eventbased profilers Java the JVMTI JVM Tools Interface API formerly JVMPI JVM Profiling Interface provides hooks to profilers for trapping events like calls classload unload thread enter leave NET Can attach a profiling agent as a COM server to the CLR using Profiling API Like Java the runtime then provides various callbacks into the agent for trapping events like method JIT enter leave object creation etc Particularly powerful in that the profiling agent can rewrite the target applications bytecode in arbitrary ways Python Python profiling includes the profile module hotshot which is callgraph based and using the syssetprofile function to trap events like ccallreturnexception pythoncallreturnexception Ruby Ruby also uses a similar interface to Python for profiling Flatprofiler in profilerb module and rubyprof a Cextension are present Statistical profilers edit Some profilers operate by sampling A sampling profiler probes the target programs call stack at regular intervals using operating system interrupts Sampling profiles are typically less numerically accurate and specific but allow the target program to run at near full speed The resulting data are not exact but a statistical approximation The actual amount of error is usually more than one sampling period In fact if a value is n times the sampling period the expected error in it is the squareroot of n sampling periods 16 In practice sampling profilers can often provide a more accurate picture of the target programs execution than other approaches as they are not as intrusive to the target program and thus dont have as many side effects such as on memory caches or instruction decoding pipelines Also since they dont affect the execution speed as much they can detect issues that would otherwise be hidden They are also relatively immune to overevaluating the cost of small frequently called routines or tight loops They can show the relative amount of time spent in user mode versus interruptible kernel mode such as system call processing Still kernel code to handle the interrupts entails a minor loss of CPU cycles diverted cache usage and is unable to distinguish the various tasks occurring in uninterruptible kernel code microsecondrange activity Dedicated hardware can go beyond this ARM CortexM3 and some recent MIPS processors JTAG interface have a PCSAMPLE register which samples the program counter in a truly undetectable manner allowing nonintrusive collection of a flat profile Some commonly used 17 statistical profilers for Javamanaged code are SmartBear Software s AQtime 18 and Microsoft s CLR Profiler 19 Those profilers also support native code profiling along with Apple Inc s Shark OSX 20 OProfile Linux 21 Intel VTune and Parallel Amplifier part of Intel Parallel Studio and Oracle Performance Analyzer 22 among others Instrumentation edit This technique effectively adds instructions to the target program to collect the required information Note that instrumenting a program can cause performance changes and may in some cases lead to inaccurate results andor heisenbugs The effect will depend on what information is being collected on the level of timing details reported and on whether basic block profiling is used in conjunction with instrumentation 23 For example adding code to count every procedureroutine call will probably have less effect than counting how many times each statement is obeyed A few computers have special hardware to collect information in this case the impact on the program is minimal Instrumentation is key to determining the level of control and amount of time resolution available to the profilers Manual Performed by the programmer eg by adding instructions to explicitly calculate runtimes simply count events or calls to measurement APIs such as the Application Response Measurement standard Automatic source level instrumentation added to the source code by an automatic tool according to an instrumentation policy Intermediate language instrumentation added to assembly or decompiled bytecodes giving support for multiple higherlevel source languages and avoiding nonsymbolic binary offset rewriting issues Compiler assisted Binary translation The tool adds instrumentation to a compiled executable Runtime instrumentation Directly before execution the code is instrumented The program run is fully supervised and controlled by the tool Runtime injection More lightweight than runtime instrumentation Code is modified at runtime to have jumps to helper functions Interpreter instrumentation edit Interpreter debug options can enable the collection of performance metrics as the interpreter encounters each target statement A bytecode control table or JIT interpreters are three examples that usually have complete control over execution of the target code thus enabling extremely comprehensive data collection opportunities HypervisorSimulator edit Hypervisor Data are collected by running the usually unmodified program under a hypervisor Example SIMMON Simulator and Hypervisor Data collected interactively and selectively by running the unmodified program under an Instruction Set Simulator See also edit Algorithmic efficiency Benchmark Java performance List of performance analysis tools PAPI is a portable interface in the form of a library to hardware performance counters on modern microprocessors Performance engineering Performance prediction Performance tuning Runtime verification Profileguided optimization Static code analysis Software archaeology Worstcase execution time WCET References edit How to find the performance bottleneck in C desktop application Stack Overflow 2012 mwparseroutput citecitationfontstyleinheritmwparseroutput citation qquotesmwparseroutput citation cs1lockfree abackgroundurluploadwikimediaorgwikipediacommonsthumb665Lockgreensvg9pxLockgreensvgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locklimited amwparseroutput citation cs1lockregistration abackgroundurluploadwikimediaorgwikipediacommonsthumbdd6Lockgrayalt2svg9pxLockgrayalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locksubscription abackgroundurluploadwikimediaorgwikipediacommonsthumbaaaLockredalt2svg9pxLockredalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput cs1subscriptionmwparseroutput cs1registrationcolor555mwparseroutput cs1subscription spanmwparseroutput cs1registration spanborderbottom1px dottedcursorhelpmwparseroutput cs1wsicon abackgroundurluploadwikimediaorgwikipediacommonsthumb44cWikisourcelogosvg12pxWikisourcelogosvgpngnorepeatbackgroundpositionright 1em centermwparseroutput codecs1codecolorinheritbackgroundinheritborderinheritpaddinginheritmwparseroutput cs1hiddenerrordisplaynonefontsize100mwparseroutput cs1visibleerrorfontsize100mwparseroutput cs1maintdisplaynonecolor33aa33marginleft03emmwparseroutput cs1subscriptionmwparseroutput cs1registrationmwparseroutput cs1formatfontsize95mwparseroutput cs1kernleftmwparseroutput cs1kernwlleftpaddingleft02emmwparseroutput cs1kernrightmwparseroutput cs1kernwlrightpaddingright02em Krauss Kirk J 2017 Performance Profiling with a Focus Develop for Performance What is code profiling Learn the 3 Types of Code Profilers Stackify Developer Tips Tricks and Resources Disqus 2016 Lawrence Eric 2016 Getting Started with Profile Guided Optimization testslashplain WordPress Krauss Kirk 2018 Matching Wildcards An Improved Algorithm for Big Data Develop for Performance List of Net Profilers 3 Different Types and Why You Need All of Them Stackify Developer Tips Tricks and Resources Disqus 2016 Unix Programmers Manual 4th Edition a b SL Graham PB Kessler and MK McKusick gprof a Call Graph Execution Profiler Proceedings of the SIGPLAN 82 Symposium on Compiler Construction SIGPLAN Notices Vol 17 No 6 pp 120126 doi101145800230806987 A Srivastava and A Eustace ATOM A system for building customized program analysis tools Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation PLDI 94 pp 196205 1994 ACM SIGPLAN Notices Best of PLDI 19791999 Homepage archive Vol 39 No 4 pp 528539 doi101145989393989446 20 Years of PLDI 19791999 A Selection Kathryn S McKinley Editor E Coppa C Demetrescu and I Finocchi InputSensitive Profiling IEEE Trans Software Eng 4012 11851205 2014 doi101109TSE20142339825 D Zaparanuks and M Hauswirth Algorithmic Profiling Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation PLDI 2012 ACM SIGPLAN Notices Vol 47 No 6 pp 6776 2012 doi10114522540642254074 T Kustner J Weidendorfer and T Weinzierl Argument Controlled Profiling Proceedings of EuroPar 2009 Parallel Processing Workshops Lecture Notes in Computer Science Vol 6043 pp 177184 2010 doi1010079783642141225 22 Timing and Profiling Basic Block Profilers OpenStax CNX Archive Ball Thomas Larus James R 1994 Optimally profiling and tracing programs PDF ACM Transactions on Programming Languages and Systems TOPLAS ACM Digital Library 16 4 13191360 doi 101145183432183527 Statistical Inaccuracy of gprof Output Archived 20120529 at the Wayback Machine Popular C Profilers Gingtage 2014 Sampling Profiler Overview AQTime 8 Reference SmartBear Software 2018 Wenzal Maira et al 2017 Profiling Overview Microsoft NET Framework Unmanaged API Reference Microsoft Performance Tools Apple Developer Tools Apple Inc 2013 Netto Zanella Arnold Ryan S 2012 Evaluate performance for Linux on Power IBM DeveloperWorks Schmidl Dirk Terboven Christian an Mey Dieter Müller Matthias S 2013 Suitability of Performance Tools for OpenMP TaskParallel Programs Proc 7th Intl Workshop on Parallel Tools for High Performance Computing pp2537 Carleton Gary Kirkegaard Knud Sehr David 1998 ProfileGuided Optimizations Dr Dobbs Journal Cite journal requires journal help External links edit Article Need for speed Eliminating performance bottlenecks on doing execution time analysis of Java applications using IBM Rational Application Developer Profiling Runtime Generated and Interpreted Code using the VTune Performance Analyzer