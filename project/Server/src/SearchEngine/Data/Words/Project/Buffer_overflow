Buffer overflow Anomaly in computer security and programming In information security and programming a buffer overflow or buffer overrun is an anomaly where a program while writing data to a buffer overruns the buffers boundary and overwrites adjacent memory locations Buffers are areas of memory set aside to hold data often while moving it from one section of a program to another or between programs Buffer overflows can often be triggered by malformed inputs if one assumes all inputs will be smaller than a certain size and the buffer is created to be that size then an anomalous transaction that produces more data could cause it to write past the end of the buffer If this overwrites adjacent data or executable code this may result in erratic program behavior including memory access errors incorrect results and crashes Exploiting the behavior of a buffer overflow is a wellknown security exploit On many systems the memory layout of a program or the system as a whole is well defined By sending in data designed to cause a buffer overflow it is possible to write into areas known to hold executable code and replace it with malicious code or to selectively overwrite data pertaining to the programs state therefore causing behavior that was not intended by the original programmer Buffers are widespread in operating system OS code so it is possible to make attacks that perform privilege escalation and gain unlimited access to the computers resources The famed Morris worm in 1988 used this as one of its attack techniques Programming languages commonly associated with buffer overflows include C and C which provide no builtin protection against accessing or overwriting data in any part of memory and do not automatically check that data written to an array the builtin buffer type is within the boundaries of that array Bounds checking can prevent buffer overflows but requires additional code and processing time Modern operating systems use a variety of techniques to combat malicious buffer overflows notably by randomizing the layout of memory or deliberately leaving space between buffers and looking for actions that write into those areas canaries Contents 1 Technical description 11 Example 2 Exploitation 21 Stackbased exploitation 22 Heapbased exploitation 23 Barriers to exploitation 24 Practicalities of exploitation 241 NOP sled technique 242 The jump to address stored in a register technique 3 Protective countermeasures 31 Choice of programming language 32 Use of safe libraries 33 Buffer overflow protection 34 Pointer protection 35 Executable space protection 36 Address space layout randomization 37 Deep packet inspection 38 Testing 4 History 5 See also 6 References 7 External links Technical description edit A buffer overflow occurs when data written to a buffer also corrupts data values in memory addresses adjacent to the destination buffer due to insufficient bounds checking This can occur when copying data from one buffer to another without first checking that the data fits within the destination buffer Example edit Further information on stackbased overflows Stack buffer overflow In the following example expressed in C a program has two variables which are adjacent in memory an 8bytelong string buffer A and a twobyte bigendian integer B char A 8 unsigned short B 1979 Initially A contains nothing but zero bytes and B contains the number 1979 variable name A B value null string 1979 hex value 00 00 00 00 00 00 00 00 07 BB Now the program attempts to store the nullterminated string excessive with ASCII encoding in the A buffer strcpy A excessive excessive is 9 characters long and encodes to 10 bytes including the null terminator but A can take only 8 bytes By failing to check the length of the string it also overwrites the value of B variable name A B value e x c e s s i v 25856 hex 65 78 63 65 73 73 69 76 65 00 Bs value has now been inadvertently replaced by a number formed from part of the character string In this example e followed by a zero byte would become 25856 Writing data past the end of allocated memory can sometimes be detected by the operating system to generate a segmentation fault error that terminates the process To prevent the buffer overflow from happening in this example the call to strcpy could be replaced with strlcpy which takes the maximum capacity of A including a nulltermination character as an additional parameter and ensures that no more than this amount of data is written to A strlcpy A excessive sizeof A When available the strlcpy library function is preferred over strncpy which does not nullterminate the destination buffer if the source strings length is greater than or equal to the size of the buffer the third argument passed to the function therefore A may not be nullterminated and cannot be treated as a valid Cstyle string Exploitation edit The techniques to exploit a buffer overflow vulnerability vary by architecture by operating system and by memory region For example exploitation on the heap used for dynamically allocated memory differs markedly from exploitation on the call stack Stackbased exploitation edit Main article Stack buffer overflow A technically inclined user may exploit stackbased buffer overflows to manipulate the program to their advantage in one of several ways By overwriting a local variable that is located near the vulnerable buffer on the stack in order to change the behavior of the program By overwriting the return address in a stack frame Once the function returns execution will resume at the return address as specified by the attacker usually a userinput filled buffer By overwriting a function pointer 1 or exception handler which is subsequently executed By overwriting a local variable or pointer of a different stack frame which will be used by the function which owns that frame later 2 If the address of the usersupplied data used to effect the stack buffer overflow is unpredictable exploiting a stack buffer overflow to cause remote code execution becomes much more difficult One technique that can be used to exploit such a buffer overflow is called trampolining In that technique an attacker will find a pointer to the vulnerable stack buffer and compute the location of their shellcode relative to that pointer Then they will use the overwrite to jump to an instruction already in memory which will make a second jump this time relative to the pointer that second jump will branch execution into the shellcode Suitable instructions are often present in large code The Metasploit Project for example maintains a database of suitable opcodes though it lists only those found in the Windows operating system 3 Heapbased exploitation edit Main article Heap overflow A buffer overflow occurring in the heap data area is referred to as a heap overflow and is exploitable in a manner different from that of stackbased overflows Memory on the heap is dynamically allocated by the application at runtime and typically contains program data Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked list pointers The canonical heap overflow technique overwrites dynamic memory allocation linkage such as malloc meta data and uses the resulting pointer exchange to overwrite a program function pointer Microsoft s GDI vulnerability in handling JPEGs is an example of the danger a heap overflow can present 4 Barriers to exploitation edit Manipulation of the buffer which occurs before it is read or executed may lead to the failure of an exploitation attempt These manipulations can mitigate the threat of exploitation but may not make it impossible Manipulations could include conversion to upper or lower case removal of metacharacters and filtering out of non alphanumeric strings However techniques exist to bypass these filters and manipulations alphanumeric code polymorphic code selfmodifying code and returntolibc attacks The same methods can be used to avoid detection by intrusion detection systems In some cases including where code is converted into Unicode 5 the threat of the vulnerability has been misrepresented by the disclosers as only Denial of Service when in fact the remote execution of arbitrary code is possible Practicalities of exploitation edit In realworld exploits there are a variety of challenges which need to be overcome for exploits to operate reliably These factors include null bytes in addresses variability in the location of shellcode differences between environments and various countermeasures in operation NOP sled technique edit Main article NOP slide Illustration of a NOPsled payload on the stack A NOPsled is the oldest and most widely known technique for successfully exploiting a stack buffer overflow 6 It solves the problem of finding the exact address of the buffer by effectively increasing the size of the target area To do this much larger sections of the stack are corrupted with the noop machine instruction At the end of the attackersupplied data after the noop instructions the attacker places an instruction to perform a relative jump to the top of the buffer where the shellcode is located This collection of noops is referred to as the NOPsled because if the return address is overwritten with any address within the noop region of the buffer the execution will slide down the noops until it is redirected to the actual malicious code by the jump at the end This technique requires the attacker to guess where on the stack the NOPsled is instead of the comparatively small shellcode 7 Because of the popularity of this technique many vendors of intrusion prevention systems will search for this pattern of noop machine instructions in an attempt to detect shellcode in use It is important to note that a NOPsled does not necessarily contain only traditional noop machine instructions any instruction that does not corrupt the machine state to a point where the shellcode will not run can be used in place of the hardware assisted noop As a result it has become common practice for exploit writers to compose the noop sled with randomly chosen instructions which will have no real effect on the shellcode execution 8 While this method greatly improves the chances that an attack will be successful it is not without problems Exploits using this technique still must rely on some amount of luck that they will guess offsets on the stack that are within the NOPsled region 9 An incorrect guess will usually result in the target program crashing and could alert the system administrator to the attackers activities Another problem is that the NOPsled requires a much larger amount of memory in which to hold a NOPsled large enough to be of any use This can be a problem when the allocated size of the affected buffer is too small and the current depth of the stack is shallow ie there is not much space from the end of the current stack frame to the start of the stack Despite its problems the NOPsled is often the only method that will work for a given platform environment or situation and as such it is still an important technique The jump to address stored in a register technique edit The jump to register technique allows for reliable exploitation of stack buffer overflows without the need for extra room for a NOPsled and without having to guess stack offsets The strategy is to overwrite the return pointer with something that will cause the program to jump to a known pointer stored within a register which points to the controlled buffer and thus the shellcode For example if register A contains a pointer to the start of a buffer then any jump or call taking that register as an operand can be used to gain control of the flow of execution 10 An instruction from ntdlldll to call the DbgPrint routine contains the i386 machine opcode for jmp esp In practice a program may not intentionally contain instructions to jump to a particular register The traditional solution is to find an unintentional instance of a suitable opcode at a fixed location somewhere within the program memory In figure E on the left is an example of such an unintentional instance of the i386 jmp esp instruction The opcode for this instruction is FF E4 11 This twobyte sequence can be found at a onebyte offset from the start of the instruction call DbgPrint at address 0x7C941EED If an attacker overwrites the program return address with this address the program will first jump to 0x7C941EED interpret the opcode FF E4 as the jmp esp instruction and will then jump to the top of the stack and execute the attackers code 12 When this technique is possible the severity of the vulnerability increases considerably This is because exploitation will work reliably enough to automate an attack with a virtual guarantee of success when it is run For this reason this is the technique most commonly used in Internet worms that exploit stack buffer overflow vulnerabilities 13 This method also allows shellcode to be placed after the overwritten return address on the Windows platform Since executables are mostly based at address 0x00400000 and x86 is a Little Endian architecture the last byte of the return address must be a null which terminates the buffer copy and nothing is written beyond that This limits the size of the shellcode to the size of the buffer which may be overly restrictive DLLs are located in high memory above 0x01000000 and so have addresses containing no null bytes so this method can remove null bytes or other disallowed characters from the overwritten return address Used in this way the method is often referred to as DLL trampolining Protective countermeasures edit Various techniques have been used to detect or prevent buffer overflows with various tradeoffs The most reliable way to avoid or prevent buffer overflows is to use automatic protection at the language level This sort of protection however cannot be applied to legacy code and often technical business or cultural constraints call for a vulnerable language The following sections describe the choices and implementations available Choice of programming language edit Assembly and CC are popular programming languages that are vulnerable to buffer overflow in part because they allow direct access to memory and are not strongly typed 14 C provides no builtin protection against accessing or overwriting data in any part of memory more specifically it does not check that data written to a buffer is within the boundaries of that buffer The standard C libraries provide many ways of safely buffering data and Cs Standard Template Library STL provides containers that can optionally perform bounds checking if the programmer explicitly calls for checks while accessing data For example a vector s member function at performs a bounds check and throws an outofrange exception if the bounds check fails 15 However C behaves just like C if the bounds check is not explicitly called Techniques to avoid buffer overflows also exist for C Languages that are strongly typed and do not allow direct memory access such as COBOL Java Python and others prevent buffer overflow from occurring in most cases 14 Many programming languages other than CC provide runtime checking and in some cases even compiletime checking which might send a warning or raise an exception when C or C would overwrite data and continue to execute further instructions until erroneous results are obtained which might or might not cause the program to crash Examples of such languages include Ada Eiffel Lisp Modula2 Smalltalk OCaml and such Cderivatives as Cyclone Rust and D The Java and NET Framework bytecode environments also require bounds checking on all arrays Nearly every interpreted language will protect against buffer overflows signaling a welldefined error condition Often where a language provides enough type information to do bounds checking an option is provided to enable or disable it Static code analysis can remove many dynamic bound and type checks but poor implementations and awkward cases can significantly decrease performance Software engineers must carefully consider the tradeoffs of safety versus performance costs when deciding which language and compiler setting to use Use of safe libraries edit The problem of buffer overflows is common in the C and C languages because they expose low level representational details of buffers as containers for data types Buffer overflows must thus be avoided by maintaining a high degree of correctness in code which performs buffer management It has also long been recommended to avoid standard library functions which are not bounds checked such as gets scanf and strcpy The Morris worm exploited a gets call in fingerd 16 Wellwritten and tested abstract data type libraries which centralize and automatically perform buffer management including bounds checking can reduce the occurrence and impact of buffer overflows The two main buildingblock data types in these languages in which buffer overflows commonly occur are strings and arrays thus libraries preventing buffer overflows in these data types can provide the vast majority of the necessary coverage Still failure to use these safe libraries correctly can result in buffer overflows and other vulnerabilities and naturally any bug in the library itself is a potential vulnerability Safe library implementations include The Better String Library 17 Vstr 18 and Erwin 19 The OpenBSD operating systems C library provides the strlcpy and strlcat functions but these are more limited than full safe library implementations In September 2007 Technical Report 24731 prepared by the C standards committee was published 20 it specifies a set of functions which are based on the standard C librarys string and IO functions with additional buffersize parameters However the efficacy of these functions for the purpose of reducing buffer overflows is disputable it requires programmer intervention on a per function call basis that is equivalent to intervention that could make the analogous older standard library functions buffer overflow safe 21 Buffer overflow protection edit Main article Buffer overflow protection Buffer overflow protection is used to detect the most common buffer overflows by checking that the stack has not been altered when a function returns If it has been altered the program exits with a segmentation fault Three such systems are Libsafe 22 and the StackGuard 23 and ProPolice 24 gcc patches Microsofts implementation of Data Execution Prevention DEP mode explicitly protects the pointer to the Structured Exception Handler SEH from being overwritten 25 Stronger stack protection is possible by splitting the stack in two one for data and one for function returns This split is present in the Forth language though it was not a securitybased design decision Regardless this is not a complete solution to buffer overflows as sensitive data other than the return address may still be overwritten Pointer protection edit Buffer overflows work by manipulating pointers including stored addresses PointGuard was proposed as a compilerextension to prevent attackers from being able to reliably manipulate pointers and addresses 26 The approach works by having the compiler add code to automatically XORencode pointers before and after they are used Because the attacker theoretically does not know what value will be used to encodedecode the pointer he cannot predict what it will point to if he overwrites it with a new value PointGuard was never released but Microsoft implemented a similar approach beginning in Windows XP SP2 and Windows Server 2003 SP1 27 Rather than implement pointer protection as an automatic feature Microsoft added an API routine that can be called at the discretion of the programmer This allows for better performance because it is not used all of the time but places the burden on the programmer to know when it is necessary Because XOR is linear an attacker may be able to manipulate an encoded pointer by overwriting only the lower bytes of an address This can allow an attack to succeed if the attacker is able to attempt the exploit multiple times or is able to complete an attack by causing a pointer to point to one of several locations such as any location within a NOP sled 28 Microsoft added a random rotation to their encoding scheme to address this weakness to partial overwrites 29 Executable space protection edit Main article Executable space protection Executable space protection is an approach to buffer overflow protection which prevents execution of code on the stack or the heap An attacker may use buffer overflows to insert arbitrary code into the memory of a program but with executable space protection any attempt to execute that code will cause an exception Some CPUs support a feature called NX No eXecute or XD eXecute Disabled bit which in conjunction with software can be used to mark pages of data such as those containing the stack and the heap as readable and writable but not executable Some Unix operating systems eg OpenBSD macOS ship with executable space protection eg WX Some optional packages include PaX 30 Exec Shield 31 Openwall 32 Newer variants of Microsoft Windows also support executable space protection called Data Execution Prevention 33 Proprietary addons include BufferShield 34 StackDefender 35 Executable space protection does not generally protect against returntolibc attacks or any other attack which does not rely on the execution of the attackers code However on 64bit systems using ASLR as described below executable space protection makes it far more difficult to execute such attacks Address space layout randomization edit Main article Address space layout randomization Address space layout randomization ASLR is a computer security feature which involves arranging the positions of key data areas usually including the base of the executable and position of libraries heap and stack randomly in a process address space Randomization of the virtual memory addresses at which functions and variables can be found can make exploitation of a buffer overflow more difficult but not impossible It also forces the attacker to tailor the exploitation attempt to the individual system which foils the attempts of internet worms 36 A similar but less effective method is to rebase processes and libraries in the virtual address space Deep packet inspection edit Main article Deep packet inspection The use of deep packet inspection DPI can detect at the network perimeter very basic remote attempts to exploit buffer overflows by use of attack signatures and heuristics These are able to block packets which have the signature of a known attack or if a long series of NoOperation instructions known as a NOPsled is detected these were once used when the location of the exploits payload is slightly variable Packet scanning is not an effective method since it can only prevent known attacks and there are many ways that a NOPsled can be encoded Shellcode used by attackers can be made alphanumeric metamorphic or selfmodifying to evade detection by heuristic packet scanners and intrusion detection systems Testing edit Checking for buffer overflows and patching the bugs that cause them naturally helps prevent buffer overflows One common automated technique for discovering them is fuzzing 37 Edge case testing can also uncover buffer overflows as can static analysis 38 Once a potential buffer overflow is detected it must be patched this makes the testing approach useful for software that is in development but less useful for legacy software that is no longer maintained or supported History edit Buffer overflows were understood and partially publicly documented as early as 1972 when the Computer Security Technology Planning Study laid out the technique The code performing this function does not check the source and destination addresses properly permitting portions of the monitor to be overlaid by the user This can be used to inject code into the monitor that will permit the user to seize control of the machine 39 Today the monitor would be referred to as the kernel The earliest documented hostile exploitation of a buffer overflow was in 1988 It was one of several exploits used by the Morris worm to propagate itself over the Internet The program exploited was a service on Unix called finger 40 Later in 1995 Thomas Lopatic independently rediscovered the buffer overflow and published his findings on the Bugtraq security mailing list 41 A year later in 1996 Elias Levy also known as Aleph One published in Phrack magazine the paper Smashing the Stack for Fun and Profit 42 a stepbystep introduction to exploiting stackbased buffer overflow vulnerabilities Since then at least two major internet worms have exploited buffer overflows to compromise a large number of systems In 2001 the Code Red worm exploited a buffer overflow in Microsofts Internet Information Services IIS 50 43 and in 2003 the SQL Slammer worm compromised machines running Microsoft SQL Server 2000 44 In 2003 buffer overflows present in licensed Xbox games have been exploited to allow unlicensed software including homebrew games to run on the console without the need for hardware modifications known as modchips 45 The PS2 Independence Exploit also used a buffer overflow to achieve the same for the PlayStation 2 The Twilight hack accomplished the same with the Wii using a buffer overflow in The Legend of Zelda Twilight Princess See also edit Billion laughs Buffer overread Computer security Endoffile Heap overflow Ping of death Port scanner Returntolibc attack Securityfocused operating system Selfmodifying code Shellcode Stack buffer overflow Uncontrolled format string References edit CORE20070219 OpenBSDs IPv6 mbufs remote kernel buffer overflow Retrieved 20070515 mwparseroutput citecitationfontstyleinheritmwparseroutput citation qquotesmwparseroutput citation cs1lockfree abackgroundurluploadwikimediaorgwikipediacommonsthumb665Lockgreensvg9pxLockgreensvgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locklimited amwparseroutput citation cs1lockregistration abackgroundurluploadwikimediaorgwikipediacommonsthumbdd6Lockgrayalt2svg9pxLockgrayalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locksubscription abackgroundurluploadwikimediaorgwikipediacommonsthumbaaaLockredalt2svg9pxLockredalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput cs1subscriptionmwparseroutput cs1registrationcolor555mwparseroutput cs1subscription spanmwparseroutput cs1registration spanborderbottom1px dottedcursorhelpmwparseroutput cs1wsicon abackgroundurluploadwikimediaorgwikipediacommonsthumb44cWikisourcelogosvg12pxWikisourcelogosvgpngnorepeatbackgroundpositionright 1em centermwparseroutput codecs1codecolorinheritbackgroundinheritborderinheritpaddinginheritmwparseroutput cs1hiddenerrordisplaynonefontsize100mwparseroutput cs1visibleerrorfontsize100mwparseroutput cs1maintdisplaynonecolor33aa33marginleft03emmwparseroutput cs1subscriptionmwparseroutput cs1registrationmwparseroutput cs1formatfontsize95mwparseroutput cs1kernleftmwparseroutput cs1kernwlleftpaddingleft02emmwparseroutput cs1kernrightmwparseroutput cs1kernwlrightpaddingright02em Modern Overflow Targets PDF Retrieved 20130705 The Metasploit Opcode Database Archived from the original on 12 May 2007 Retrieved 20070515 Microsoft Technet Security Bulletin MS04028 Archived from the original on 20110804 Retrieved 20070515 Creating Arbitrary Shellcode In Unicode Expanded Strings PDF Archived from the original PDF on 20060105 Retrieved 20070515 Vangelis 20041208 Stackbased Overflow Exploit Introduction to Classical and Advanced Overflow Technique Wowhacker via Neworder Archived from the original text on August 18 2007 Cite journal requires journal help Balaban Murat Buffer Overflows Demystified text Enderunixorg Cite journal requires journal help Akritidis P Evangelos P Markatos M Polychronakis Kostas D Anagnostakis 2005 STRIDE Polymorphic Sled Detection through Instruction Sequence Analysis PDF Proceedings of the 20th IFIP International Information Security Conference IFIPSEC 2005 IFIP International Information Security Conference Archived from the original PDF on 20120901 Retrieved 20120304 Klein Christian September 2004 Buffer Overflow PDF Archived from the original PDF on 20070928 Cite journal requires journal help Shah Saumil 2006 Writing Metasploit Plugins from vulnerability to exploit PDF Hack In The Box Kuala Lumpur Retrieved 20120304 Intel 64 and IA32 Architectures Software Developers Manual Volume 2A Instruction Set Reference AM PDF Intel Corporation May 2007 pp3508 Archived from the original PDF on 20071129 Alvarez Sergio 20040905 Win32 Stack BufferOverFlow Real Life VulnDev Process PDF IT Security Consulting Retrieved 20120304 Cite journal requires journal help Ukai Yuji Soeder Derek Permeh Ryan 2004 Environment Dependencies in Windows Exploitation BlackHat Japan Japan eEye Digital Security Retrieved 20120304 a b httpswwwowasporgindexphpBufferOverflows Buffer Overflows article on OWASP vectorat C Reference Cpluspluscom Retrieved 20140327 httpwiretapareacomGopherLibraryTechdocVirusinetvir823 permanent dead link The Better String Library The Vstr Homepage Retrieved 20070515 The Erwin Homepage Retrieved 20070515 International Organization for Standardization 2007 Information technology Programming languages their environments and system software interfaces Extensions to the C library Part 1 Boundschecking interfaces ISO Online Browsing Platform CERT Secure Coding Initiative Retrieved 20070730 Libsafe at FSForg Retrieved 20070520 StackGuard Automatic Adaptive Detection and Prevention of BufferOverflow Attacks by Cowan et al PDF Retrieved 20070520 ProPolice at XORG Archived from the original on 12 February 2007 Retrieved 20070520 Bypassing Windows Hardwareenforced Data Execution Prevention Archived from the original on 20070430 Retrieved 20070520 12th USENIX Security Symposium Technical Paper wwwusenixorg Retrieved 3 April 2018 Protecting against Pointer Subterfuge Kinda msdncom Archived from the original on 20100502 Retrieved 3 April 2018 USENIX The Advanced Computing Systems Association PDF wwwusenixorg Retrieved 3 April 2018 Protecting against Pointer Subterfuge Redux msdncom Archived from the original on 20091219 Retrieved 3 April 2018 PaX Homepage of the PaX team Retrieved 20070603 KernelTrapOrg Archived from the original on 20120529 Retrieved 20070603 Openwall Linux kernel patch 2434ow1 Archived from the original on 20120219 Retrieved 20070603 Microsoft Technet Data Execution Prevention Archived from the original on 20060622 Retrieved 20060630 BufferShield Prevention of Buffer Overflow Exploitation for Windows Retrieved 20070603 NGSec Stack Defender Archived from the original on 20070513 Retrieved 20070603 PaX at GRSecuritynet Retrieved 20070603 The Exploitant Security info and tutorials Retrieved 20091129 Larochelle David Evans David 13 August 2001 Statically Detecting Likely Buffer Overflow Vulnerabilities USENIX Security Symposium 32 Computer Security Technology Planning Study PDF p61 Archived from the original PDF on 20110721 Retrieved 20071102 A Tour of The Worm by Donn Seeley University of Utah Archived from the original on 20070520 Retrieved 20070603 Bugtraq security mailing list archive Archived from the original on 20070901 Retrieved 20070603 Smashing the Stack for Fun and Profit by Aleph One Retrieved 20120905 eEye Digital Security Retrieved 20070603 Microsoft Technet Security Bulletin MS02039 Archived from the original on 20080307 Retrieved 20070603 Hacker breaks Xbox protection without modchip Archived from the original on 20070927 Retrieved 20070603 External links edit Discovering and exploiting a remote buffer overflow vulnerability in an FTP server by Raykoid666 Smashing the Stack for Fun and Profit by Aleph One Gerg Isaac 20050502 An Overview and Example of the BufferOverflow Exploit PDF IAnewsletter Information Assurance Technology Analysis Center 7 4 1621 Archived from the original PDF on 20060927 Retrieved 20190317 CERT Secure Coding Standards CERT Secure Coding Initiative Secure Coding in C and C SANS inside the buffer overflow attack Advances in adjacent memory overflows by Nomenumbra A Comparison of Buffer Overflow Prevention Implementations and Weaknesses More Security Whitepapers about Buffer Overflows Chapter 12 Writing Exploits III from Sockets Shellcode Porting Coding Reverse Engineering Exploits and Tool Coding for Security Professionals by James C Foster ISBN 1597490059 Detailed explanation of how to use Metasploit to develop a buffer overflow exploit from scratch Computer Security Technology Planning Study James P Anderson ESDTR7351 ESDAFSC Hanscom AFB Bedford MA 01731 October 1972 NTIS AD758 206 Buffer Overflows Anatomy of an Exploit by Nevermore Secure Programming with GCC and GLibc 2008 by Marcel Holtmann v t e Memory management Memory management as a function of an operating system Manual memory management Static memory allocation C dynamic memory allocation new and delete C Virtual memory Demand paging Page table Paging Virtual memory compression Hardware Memory management unit Translation lookaside buffer Garbage collection Boehm garbage collector Concurrent mark sweep collector Finalizer Garbage Garbagefirst collector Markcompact algorithm Reference counting Tracing garbage collection Strong reference Weak reference Memory segmentation Protected mode Real mode Virtual 8086 mode x86 memory segmentation Memory safety Buffer overflow Buffer overread Dangling pointer Stack overflow Issues Fragmentation Memory leak Unreachable memory Other Automatic variable International Symposium on Memory Management Regionbased memory management Authority control GND 47524509