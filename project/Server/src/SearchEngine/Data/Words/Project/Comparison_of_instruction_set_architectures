Comparison of instruction set architectures An instruction set architecture ISA is an abstract model of a computer It is also referred to as architecture or computer architecture A realization of an ISA is called an implementation An ISA permits multiple implementations that may vary in performance physical size and monetary cost among other things because the ISA serves as the interface between software and hardware Software that has been written for an ISA can run on different implementations of the same ISA This has enabled binary compatibility between different generations of computers to be easily achieved and the development of computer families Both of these developments have helped to lower the cost of computers and to increase their applicability For these reasons the ISA is one of the most important abstractions in computing today An ISA defines everything a machine language programmer needs to know in order to program a computer What an ISA defines differs between ISAs in general ISAs define the supported data types what state there is such as the main memory and registers and their semantics such as the memory consistency and addressing modes the instruction set the set of machine instructions that comprises a computers machine language and the inputoutput model Contents 1 Base 11 Bits 12 Operands 13 Endianness 2 Instruction sets 3 See also 4 References Base edit In the early decades of computing there were computers that used binary decimal 1 and even ternary 2 3 Contemporary computers are almost exclusively binary Bits edit Computer architectures are often described as n bit architectures Today n is often 8 16 32 or 64 but other sizes have been used This is actually a strong simplification A computer architecture often has a few more or less natural datasizes in the instruction set but the hardware implementation of these may be very different Many architectures have instructions operating on half andor twice the size of respective processors major internal datapaths Examples of this are the 8080 Z80 MC68000 as well as many others On this type of implementations a twice as wide operation typically also takes around twice as many clock cycles which is not the case on high performance implementations On the 68000 for instance this means 8 instead of 4 clock ticks and this particular chip may be described as a 32bit architecture with a 16bit implementation The external databus width is often not useful to determine the width of the architecture the NS32008 NS32016 and NS32032 were basically the same 32bit chip with different external data buses The NS32764 had a 64bit bus but used 32bit registers The width of addresses may or may not be different from the width of dataEarly 32bit microprocessors often had a 24bit address as did the System360 processors Operands edit Main article instruction set Number of operands The number of operands is one of the factors that may give an indication about the performance of the instruction setA threeoperand architecture will allow A B C to be computed in one instruction A twooperand architecture will allow A A B to be computed in one instruction so two instructions will need to be executed to simulate a single threeoperand instruction A BA A C Endianness edit An architecture may use big or little endianness or both or be configurable to use either Little endian processors order bytes in memory with the least significant byte of a multibyte value in the lowestnumbered memory location Big endian architectures instead order them with the most significant byte at the lowestnumbered address The x86 architecture as well as several 8bit architectures are little endian Most RISC architectures SPARC Power PowerPC MIPS were originally big endian ARM was little endian but many including ARM are now configurable Endianness only applies to processors that allow individual addressing of units of data such as bytes that are smaller than the basic addressable machine word Instruction sets edit Usually the number of registers is a power of two eg 8 16 32 In some cases a hardwiredtozero pseudoregister is included as part of register files of architectures mostly to simplify indexing modes This table only counts the integer registers usable by general instructions at any moment Architectures always include specialpurpose registers such as the program pointer PC Those are not counted unless mentioned Note that some architectures such as SPARC have register window for those architectures the count below indicates how many registers are available within a register window Also nonarchitected registers for register renaming are not counted Note a common type of architecture loadstore is a synonym for Register Register below meaning no instructions access memory except special load to registers and store from registers with the possible exceptions of atomic memory operations for locking The table below compares basic information about instruction sets to be implemented in the CPU architectures Archi tecture Bits Version Intro duced Max operands Type Design Registers excluding FPvector Instruction encoding Branch evaluation Endian ness Extensions Open Royalty free 6502 8 1975 1 Register Memory CISC 3 Variable 8 to 32bit Condition register Little 680x0 32 1979 2 Register Memory CISC 8 data and 8 address Variable Condition register Big 8080 8 1974 2 Register Memory CISC 8 Variable 8 to 24bits Condition register Little 8051 32 832 1977 1 RegisterRegister CISC 32 in 4bit 16 in 8bit 8 in 16bit 4 in 32bit Variable 8bit to 128bytes Compare and branch Little x86 16 32 64 163264 1978 2 integer 3 AVX 4 Register Memory CISC 8 4 or 6 segment reg 1632bit 16 2 segment reg gscs 64bit Variable 8086 80386 variable between 1 and 6 bytes w MMU intel SDK 80486 2 to 5 bytes with prefix pentium and onward 2 to 4 bytes with prefix x64 4 bytes prefix third party x86 emulation 1 to 15 bytes wo prefix MMU SSEMMX 4 bytes w prefix AVX 8 Bytes w prefix Condition code Little x87 IA32 MMX 3DNow SSE SSE2 PAE x8664 SSE3 SSSE3 SSE4 BMI AVX AES FMA XOP F16C No No Alpha 64 1992 3 Register Register RISC 32 including zero Fixed 32bit Condition register Bi MVI BWX FIX CIX No ARC 1632 ARCv2 5 1996 3 Register Register RISC 16 or 32 including SP user can increase to 60 Variable 16 and 32bit Compare and branch Bi APEX Userdefined instructions ARMA32 32 ARMv1v8 1983 3 Register Register RISC 15 Fixed 32bit Condition code Bi NEON Jazelle VFP TrustZone LPAE No ThumbT32 32 ARMv6ARMv8 1983 3 Register Register RISC 7 with 16bit Thumb instructions 15 with 32bit Thumb2 instructions Thumb Fixed 16bit Thumb2 Variable 16 and 32bit Condition code Bi NEON Jazelle VFP TrustZone LPAE No A64 64 ARMv8A 6 2011 7 3 Register Register RISC 32 including the stack pointerzero register Fixed 32bit Condition code Bi none all ARMv7 extensions are nonoptional No AVR 8 1997 2 Register Register RISC 32 16 on reduced architecture Variable mostly 16bit four instructions are 32bit Condition register skip conditioned on an IO or general purpose register bit compare and skip Little AVR32 32 Rev 2 2006 23 RISC 15 Variable 8 Big Java Virtual Machine Blackfin 32 2000 3 9 Register Register RISC 10 2 accumulators 8 data registers 8 pointer registers 4 index registers 4 buffer registers Variable 16 or 32bit Condition code Little 11 CDC 6000 60 1964 3 Register Memory RISC 24 8 18bit address reg 8 18bit index reg 8 60bit operand reg Variable 15 30 and 60bit Compare and branch na 12 CompareMove Unit additional Peripheral Processing Units No No Crusoe native VLIW 32 13 2000 1 Register Register 13 VLIW 13 14 1 in native push stack mode 6 in x86 emulation 8 in x87MMX mode 50 in rename status 12 integer 48 shadow 4 debug in native VLIW mode 13 14 Variable 64 or 128bit in native mode 15 bytes in x86 emulation 14 Condition code 13 Little Elbrus native VLIW 64 Elbrus4S 2014 1 Register Register 13 VLIW 864 64 Condition code Little Justintime dynamic trans lation x87 IA32 MMX SSE SSE2 x8664 SSE3 AVX No No DLX 32 1990 3 RISC 32 Fixed 32bit Big eSiRISC 1632 2009 3 Register Register RISC 872 Variable 16 or 32bit Compare and branch and condition register Bi Userdefined instructions No No Itanium IA64 64 2001 Register Register EPIC 128 Fixed 128 bit bundles with 5 bit template tag and 3 instructions each 41 bit long Condition register Bi selectable Intel Virtualization Technology No No M32R 32 1997 3 Register Register RISC 16 Variable 16 or 32bit Condition register Bi Mico32 32 2006 3 Register Register RISC 32 15 Fixed 32bit Compare and branch Big Userdefined instructions Yes 16 Yes MIPS 64 3264 6 17 18 1981 13 Register Register RISC 432 including zero Fixed 32bit Condition register Bi MDMX MIPS3D Yes Yes 19 MMIX 64 1999 3 Register Register RISC 256 Fixed 32bit Big Yes Yes NS320xx 32 1982 5 Memory Memory CISC 8 Variable Huffman coded up to 23bytes long Condition code Little BitBlt instructions OpenRISC 32 64 13 20 2010 3 Register Register RISC 16 or 32 Fixed Yes Yes PARISC HPPA 64 3264 20 1986 3 Register Register RISC 32 Fixed 32bit Compare and branch Big Bi MAX No PDP8 21 12 1966 Register Memory CISC 1 accumulator 1 multiplier quotient register Fixed 12bit Condition register Test and branch EAEExtended Arithmetic Element PDP11 16 1970 3 Memory Memory CISC 8 includes stack pointer though any register can act as stack pointer Fixed 16bit Condition code Little Floating Point Commercial Instruction Set No No POWER PowerPC Power ISA 3264 3264 30B 22 1990 3 Register Register RISC 32 Fixed 32bit Variable Condition code BigBi AltiVec APU VSX Cell Yes Yes RISCV 32 64 128 22 23 2010 3 Register Register RISC 32 including zero Variable Compare and branch Little Yes Yes RX 643216 2000 3 Memory Memory CISC 4 integer 4 address Variable Compare and branch Little No Score 1632 2005 RISC Little SPARC 64 3264 OSA2017 24 1985 3 Register Register RISC 32 including zero Fixed 32bit Condition code Big Bi VIS Yes Yes 25 SuperH SH 32 1994 2 Register Register Register Memory RISC 16 Fixed 16 or 32bit Variable Condition code single bit Bi System360 System370 zArchitecture 64 3264 1964 2 most 3 FMA distinct operand facility 4 some vector inst Register Memory Memory Memory Register Register CISC 16 Variable 16 32 or 48bit Condition code compare and branch Big No No Transputer 32 464 1987 1 Stack machine MISC 3 as stack Variable 8 120 bytes Compare and branch Little VAX 32 1977 6 Memory Memory CISC 16 Variable Compare and branch Little Z80 8 1976 2 Register Memory CISC 17 Variable 8 to 32bits Condition register Little Archi tecture Bits Version Intro duced Max operands Type Design Registers excluding FPvector Instruction encoding Branch evaluation Endian ness Extensions Open Royalty free See also edit Central processing unit CPU CPU design Comparison of CPU microarchitectures Instruction set Microprocessor Benchmark computing References edit da Cruz Frank October 18 2004 The IBM Naval Ordnance Research Calculator Columbia University Computing History Retrieved January 28 2019 mwparseroutput citecitationfontstyleinheritmwparseroutput citation qquotesmwparseroutput citation cs1lockfree abackgroundurluploadwikimediaorgwikipediacommonsthumb665Lockgreensvg9pxLockgreensvgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locklimited amwparseroutput citation cs1lockregistration abackgroundurluploadwikimediaorgwikipediacommonsthumbdd6Lockgrayalt2svg9pxLockgrayalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locksubscription abackgroundurluploadwikimediaorgwikipediacommonsthumbaaaLockredalt2svg9pxLockredalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput cs1subscriptionmwparseroutput cs1registrationcolor555mwparseroutput cs1subscription spanmwparseroutput cs1registration spanborderbottom1px dottedcursorhelpmwparseroutput cs1wsicon abackgroundurluploadwikimediaorgwikipediacommonsthumb44cWikisourcelogosvg12pxWikisourcelogosvgpngnorepeatbackgroundpositionright 1em centermwparseroutput codecs1codecolorinheritbackgroundinheritborderinheritpaddinginheritmwparseroutput cs1hiddenerrordisplaynonefontsize100mwparseroutput cs1visibleerrorfontsize100mwparseroutput cs1maintdisplaynonecolor33aa33marginleft03emmwparseroutput cs1subscriptionmwparseroutput cs1registrationmwparseroutput cs1formatfontsize95mwparseroutput cs1kernleftmwparseroutput cs1kernwlleftpaddingleft02emmwparseroutput cs1kernrightmwparseroutput cs1kernwlrightpaddingright02em Russian Virtual Computer Museum Hall of Fame Nikolay Petrovich Brusentsov Trogemann Georg Nitussov Alexander Y Ernst Wolfgang 2001 Computing in Russia the history of computer devices and information technology revealed ViewegTeubner Verlag pp19 55 57 91 104107 ISBN 9783528057572 The LEA 8086 later and IMULimmediate 80186 later instructions accept three operands most other instructions of the base integer ISA accept no more than two operands httpswwwsynopsyscomdesignwareipprocessorsolutionsarcprocessorshtml ARMv8 Technology Preview ARM goes 64bit with new ARMv8 chip architecture Retrieved 26 May 2012 AVR32 Architecture Document PDF Atmel Retrieved 20080615 Blackfin manual PDF analogcom Blackfin Processor Architecture Overview Analog Devices Retrieved 20090510 Blackfin memory architecture Analog Devices Archived from the original on 20110616 Retrieved 20091218 Since memory is an array of 60bit words with no means to access subunits big endian vs little endian makes no sense The optional CMU unit uses big endian semantics a b c d e f Crusoe Exposed Transmeta TM5xxx Architecture 2 Real World Technologies a b c Alexander Klaiber January 2000 The Technology Behind Crusoe Processors PDF Transmeta Corporation Retrieved December 6 2013 LatticeMico32 Architecture Lattice Semiconductor Archived from the original on 23 June 2010 LatticeMico32 Open Source Licensing Lattice Semiconductor Archived from the original on 20 June 2010 MIPS64 Architecture for Programmers Release 6 MIPS32 Architecture for Programmers Release 6 MIPS Open OpenRISC Architecture Revisions PDP8 Users Handbook PDF bitsaversorg 20190216 Power ISA Version 30 openpowerfoundationorg 20161130 Retrieved 20170106 RISCV ISA Specifications Retrieved 17 June 2019 Oracle SPARC Processor Documentation SPARC Architecture License v t e Processor technologies Models Turing machine Universal PostTuring Quantum Belt machine Stack machine Finitestate machine with datapath Hierarchical Queue automaton Register machines Counter Pointer Randomaccess Randomaccess stored program Architecture Microarchitecture Von Neumann Harvard modified Dataflow Transporttriggered Cellular Endianness Memory access NUMA HUMA Loadstore Registermemory Cache hierarchy Memory hierarchy Virtual memory Secondary storage Heterogeneous Fabric Multiprocessing Cognitive Neuromorphic Instruction set architectures Types CISC RISC Applicationspecific EDGE TRIPS VLIW EPIC MISC OISC NISC ZISC comparison addressing modes x86 ARM MIPS Power ISA SPARC Itanium Unicore MicroBlaze RISCV others Execution Instruction pipelining Pipeline stall Operand forwarding Classic RISC pipeline Hazards Data dependency Structural Control False sharing Outoforder Tomasulo algorithm Reservation station Reorder buffer Register renaming Speculative Branch prediction Memory dependence prediction Parallelism Level Bit Bitserial Word Instruction Pipelining Scalar Superscalar Task Thread Process Data Vector Memory Distributed Multithreading Temporal Simultaneous Hyperthreading Speculative Preemptive Cooperative Flynns taxonomy SISD SIMD SWAR SIMT MISD MIMD SPMD Processor performance Transistor count Instructions per cycle IPC Cycles per instruction CPI Instructions per second IPS Floatingpoint operations per second FLOPS Transactions per second TPS Synaptic updates per second SUPS Performance per watt PPW Cache performance metrics Computer performance by orders of magnitude Types Central processing unit CPU Graphics processing unit GPU GPGPU Vector Barrel Stream Coprocessor ASIC FPGA CPLD Multichip module MCM System in package SiP By application Microprocessor Microcontroller Mobile Notebook Ultralowvoltage ASIP Systems on chip System on a chip SoC Multiprocessor MPSoC Programmable PSoC Network on a chip NoC Hardware accelerators AI accelerator Vision processing unit VPU Physics processing unit PPU Digital signal processor DSP Tensor processing unit TPU Secure cryptoprocessor Network processor Baseband processor Word size 1bit 2bit 4bit 8bit 16bit 32bit 48bit 64bit 128bit 256bit 512bit others variable Core count Singlecore Multicore Manycore Heterogeneous architecture Components Core Cache CPU cache replacement policies coherence Bus Clock rate Clock signal FIFO Functional units Arithmetic logic unit ALU Address generation unit AGU Floatingpoint unit FPU Memory management unit MMU Loadstore unit Translation lookaside buffer TLB Integrated memory controller IMC Logic Combinational Sequential Glue Logic gate Quantum Array Registers Processor register Status register Stack register Register file Memory buffer Program counter Control unit Instruction unit Data buffer Write buffer Microcode ROM Counter Datapath Multiplexer Demultiplexer Adder Multiplier CPU Binary decoder Address decoder Sum addressed decoder Barrel shifter Circuitry Integrated circuit 3D Mixedsignal Power management Boolean Digital Analog Quantum Switch Power management PMU APM ACPI Dynamic frequency scaling Dynamic voltage scaling Clock gating Performance per watt PPW Race to sleep Related History of generalpurpose CPUs Microprocessor chronology Processor design Digital electronics Hardware security module Semiconductor device fabrication Ticktock model