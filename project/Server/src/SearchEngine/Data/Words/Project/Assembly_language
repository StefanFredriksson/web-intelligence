Assembly language Low level programming language Assembly language Typical secondary output from an assemblershowing original assembly language right for the Motorola MC6800 and the assembled form Paradigm Imperative unstructured Firstappeared 1949 70years ago 1949 In computer programming assembly language or assembler language 1 often abbreviated asm is any lowlevel programming language in which there is a very strong correspondence between the instructions in the language and the architectures machine code instructions 2 Because assembly depends on the machine code instructions every assembler has its own assembly language which is designed for exactly one specific computer architecture Assembly language may also be called symbolic machine code 3 4 Assembly code is converted into executable machine code by a utility program referred to as an assembler The conversion process is referred to as assembly as in assembling the source code Assembly language usually has one statement per machine instruction 11 but comments and statements that are assembler directives 5 macros 6 1 and symbolic labels of program and memory locations are often also supported Each assembly language is specific to a particular computer architecture and sometimes to an operating system 7 However some assembly languages do not provide specific syntax for operating system calls and most assembly languages can be used universally with any operating system as the language provides access to all the real capabilities of the processor upon which all system call mechanisms ultimately rest In contrast to assembly languages most highlevel programming languages are generally portable across multiple architectures but require interpreting or compiling a much more complicated task than assembling Contents 1 Assembly language syntax 2 Terminology 3 Key concepts 31 Assembler 311 Number of passes 312 Highlevel assemblers 32 Assembly language 4 Language design 41 Basic elements 411 Opcode mnemonics and extended mnemonics 412 Data directives 413 Assembly directives 42 Macros 43 Support for structured programming 5 Use of assembly language 51 Historical perspective 52 Current usage 53 Typical applications 6 See also 7 Notes 8 References 9 Further reading 10 External links Assembly language syntax edit Assembly language uses a mnemonic to represent each lowlevel machine instruction or opcode typically also each architectural register flag etc Many operations require one or more operands in order to form a complete instruction Most assemblers permit named constants registers and labels for program and memory locations and can calculate expressions for operands Thus the programmers are freed from tedious repetitive calculations and assembler programs are much more readable than machine code Depending on the architecture these elements may also be combined for specific instructions or addressing modes using offsets or other data as well as fixed addresses Many assemblers offer additional mechanisms to facilitate program development to control the assembly process and to aid debugging Terminology edit A macro assembler includes a macroinstruction facility so that parameterized assembly language text can be represented by a name and that name can be used to insert the expanded text into other code A cross assembler see also cross compiler is an assembler that is run on a computer or operating system the host system of a different type from the system on which the resulting code is to run the target system Crossassembling facilitates the development of programs for systems that do not have the resources to support software development such as an embedded system or a microcontroller In such a case the resulting object code must be transferred to the target system via readonly memory ROM EPROM etc a programmer when the readonly memory is integrated in the device as in microcontrollers or a data link using either an exact bitbybit copy of the object code or a textbased representation of that code such as Motorola Srecord or Intel HEX A highlevel assembler is a program that provides language abstractions more often associated with highlevel languages such as advanced control structures IFTHENELSE DO CASE etc and highlevel abstract data types including structuresrecords unions classes and sets A microassembler is a program that helps prepare a microprogram called firmware to control the low level operation of a computer A metaassembler is a term used in some circles for a program that accepts the syntactic and semantic description of an assembly language and generates an assembler for that language 8 Assembly time is the computational step where an assembler is run Key concepts edit Assembler edit An assembler program creates object code by translating combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents This representation typically includes an operation code opcode as well as other control bits and data The assembler also calculates constant expressions and resolves symbolic names for memory locations and other entities 9 The use of symbolic references is a key feature of assemblers saving tedious calculations and manual address updates after program modifications Most assemblers also include macro facilities for performing textual substitution eg to generate common short sequences of instructions as inline instead of called subroutines Some assemblers may also be able to perform some simple types of instruction set specific optimizations One concrete example of this may be the ubiquitous x86 assemblers from various vendors Most of them are able to perform jumpinstruction replacements long jumps replaced by short or relative jumps in any number of passes on request Others may even do simple rearrangement or insertion of instructions such as some assemblers for RISC architectures that can help optimize a sensible instruction scheduling to exploit the CPU pipeline as efficiently as possible citation needed Like early programming languages such as Fortran Algol Cobol and Lisp assemblers have been available since the 1950s and the first generations of text based computer interfaces However assemblers came first as they are far simpler to write than compilers for highlevel languages This is because each mnemonic along with the addressing modes and operands of an instruction translates rather directly into the numeric representations of that particular instruction without much context or analysis There have also been several classes of translators and semi automatic code generators with properties similar to both assembly and high level languages with Speedcode as perhaps one of the better known examples There may be several assemblers with different syntax for a particular CPU or instruction set architecture For instance an instruction to add memory data to a register in a x86 family processor might be add eaxebx in original Intel syntax whereas this would be written addl ebxeax in the ATT syntax used by the GNU Assembler Despite different appearances different syntactic forms generally generate the same numeric machine code See below A single assembler may also have different modes in order to support variations in syntactic forms as well as their exact semantic interpretations such as FASM syntax TASM syntax ideal mode etc in the special case of x86 assembly programming Number of passes edit There are two types of assemblers based on how many passes through the source are needed how many times the assembler reads the source to produce the object file Onepass assemblers go through the source code once Any symbol used before it is defined will require errata at the end of the object code or at least no earlier than the point where the symbol is defined telling the linker or the loader to go back and overwrite a placeholder which had been left where the as yet undefined symbol was used Multipass assemblers create a table with all symbols and their values in the first passes then use the table in later passes to generate code In both cases the assembler must be able to determine the size of each instruction on the initial passes in order to calculate the addresses of subsequent symbols This means that if the size of an operation referring to an operand defined later depends on the type or distance of the operand the assembler will make a pessimistic estimate when first encountering the operation and if necessary pad it with one or more nooperation instructions in a later pass or the errata In an assembler with peephole optimization addresses may be recalculated between passes to allow replacing pessimistic code with code tailored to the exact distance from the target The original reason for the use of onepass assemblers was speed of assembly often a second pass would require rewinding and rereading the program source on tape or rereading a deck of cards or punched paper tape Later computers with much larger memories especially disc storage had the space to perform all necessary processing without such rereading The advantage of the multipass assembler is that the absence of errata makes the linking process or the program load if the assembler directly produces executable code faster 10 Example in the following code snippet a onepass assembler would be able to determine the address of the backward reference BKWD when assembling statement S2 but would not be able to determine the address of the forward reference FWD when assembling the branch statement S1 indeed FWD may be undefined A twopass assembler would determine both addresses in pass 1 so they would be known when generating code in pass 2 S1 B FWD FWD EQU BKWD EQU S2 B BKWD Highlevel assemblers edit More sophisticated highlevel assemblers provide language abstractions such as Highlevel procedurefunction declarations and invocations Advanced control structures IFTHENELSE SWITCH Highlevel abstract data types including structuresrecords unions classes and sets Sophisticated macro processing although available on ordinary assemblers since the late 1950s for IBM 700 series and since the 1960s for IBM360 amongst other machines Objectoriented programming features such as classes objects abstraction polymorphism and inheritance 11 See Language design below for more details Assembly language edit A program written in assembly language consists of a series of mnemonic processor instructions and metastatements known variously as directives pseudoinstructions and pseudoops comments and data Assembly language instructions usually consist of an opcode mnemonic followed by a list of data arguments or parameters 12 These are translated by an assembler into machine language instructions that can be loaded into memory and executed For example the instruction below tells an x86 IA32 processor to move an immediate 8bit value into a register The binary code for this instruction is 10110 followed by a 3bit identifier for which register to use The identifier for the AL register is 000 so the following machine code loads the AL register with the data 01100001 13 10110000 01100001 This binary computer code can be made more humanreadable by expressing it in hexadecimal as follows B0 61 Here B0 means Move a copy of the following value into AL and 61 is a hexadecimal representation of the value 01100001 which is 97 in decimal Assembly language for the 8086 family provides the mnemonic MOV an abbreviation of move for instructions such as this so the machine code above can be written as follows in assembly language complete with an explanatory comment if required after the semicolon This is much easier to read and to remember MOV AL 61h Load AL with 97 decimal 61 hex In some assembly languages including this one the same mnemonic such as MOV may be used for a family of related instructions for loading copying and moving data whether these are immediate values values in registers or memory locations pointed to by values in registers or by immediate aka direct addresses Other assemblers may use separate opcode mnemonics such as L for move memory to register ST for move register to memory LR for move register to register MVI for move immediate operand to memory etc If the same mnemonic is used for different instructions that means that the mnemonic corresponds to several different binary instruction codes excluding data eg the 61h in this example depending on the operands that follow the mnemonic For example for the x86IA32 CPUs the Intel assembly language syntax MOV AL AH represents an instruction that moves the contents of register AH into register AL The 14 hexadecimal form of this instruction is 88 E0 The first byte 88h identifies a move between a bytesized register and either another register or memory and the second byte E0h is encoded with three bitfields to specify that both operands are registers the source is AH and the destination is AL In a case like this where the same mnemonic can represent more than one binary instruction the assembler determines which instruction to generate by examining the operands In the first example the operand 61h is a valid hexadecimal numeric constant and is not a valid register name so only the B0 instruction can be applicable In the second example the operand AH is a valid register name and not a valid numeric constant hexadecimal decimal octal or binary so only the 88 instruction can be applicable Assembly languages are always designed so that this sort of unambiguousness is universally enforced by their syntax For example in the Intel x86 assembly language a hexadecimal constant must start with a numeral digit so that the hexadecimal number A equal to decimal ten would be written as 0Ah or 0AH not AH specifically so that it cannot appear to be the name of register AH The same rule also prevents ambiguity with the names of registers BH CH and DH as well as with any userdefined symbol that ends with the letter H and otherwise contains only characters that are hexadecimal digits such as the word BEACH Returning to the original example while the x86 opcode 10110000 B0 copies an 8bit value into the AL register 10110001 B1 moves it into CL and 10110010 B2 does so into DL Assembly language examples for these follow 13 MOV AL 1h Load AL with immediate value 1 MOV CL 2h Load CL with immediate value 2 MOV DL 3h Load DL with immediate value 3 The syntax of MOV can also be more complex as the following examples show 15 MOV EAX EBX Move the 4 bytes in memory at the address contained in EBX into EAX MOV ESI EAX CL Move the contents of CL into the byte at address ESIEAX MOV DS DX Move the contents of DX into segment register DS In each case the MOV mnemonic is translated directly into one of the opcodes 888C 8E A0A3 B0BF C6 or C7 by an assembler and the programmer normally does not have to know or remember which 13 Transforming assembly language into machine code is the job of an assembler and the reverse can at least partially be achieved by a disassembler Unlike highlevel languages there is a onetoone correspondence between many simple assembly statements and machine language instructions However in some cases an assembler may provide pseudoinstructions essentially macros which expand into several machine language instructions to provide commonly needed functionality For example for a machine that lacks a branch if greater or equal instruction an assembler may provide a pseudoinstruction that expands to the machines set if less than and branch if zero on the result of the set instruction Most fullfeatured assemblers also provide a rich macro language discussed below which is used by vendors and programmers to generate more complex code and data sequences Since the information about pseudoinstructions and macros defined in the assembler environment is not present in the object program a disassembler cannot reconstruct the macro and pseudoinstruction invocations but can only disassemble the actual machine instructions that the assembler generated from those abstract assemblylanguage entities Likewise since comments in the assembly language source file are ignored by the assembler and have no effect on the object code it generates a disassembler is always completely unable to recover source comments Each computer architecture has its own machine language Computers differ in the number and type of operations they support in the different sizes and numbers of registers and in the representations of data in storage While most generalpurpose computers are able to carry out essentially the same functionality the ways they do so differ the corresponding assembly languages reflect these differences Multiple sets of mnemonics or assemblylanguage syntax may exist for a single instruction set typically instantiated in different assembler programs In these cases the most popular one is usually that supplied by the CPU manufacturer and used in its documentation Two examples of CPUs that have two different sets of mnemonics are the Intel 8080 family and the Intel 80868088 Because Intel claimed copyright on its assembly language mnemonics on each page of their documentation published in the 1970s and early 1980s at least some companies that independently produced CPUs compatible with Intel instruction sets invented their own mnemonics The Zilog Z80 CPU an enhancement of the Intel 8080A supports all the 8080A instructions plus many more Zilog invented an entirely new assembly language not only for the new instructions but also for all of the 8080A instructions For example where Intel uses the mnemonics MOV MVI LDA STA LXI LDAX STAX LHLD and SHLD for various data transfer instructions the Z80 assembly language uses the mnemonic LD for all of them A similar case is the NEC V30 and V20 CPUs enhanced copies of the Intel 8086 and 8088 respectively Like Zilog with the Z80 NEC invented new mnemonics for all of the 8086 and 8088 instructions to avoid accusations of infringement of Intels copyright It is questionable whether such copyrights can be valid and later CPU companies such as AMD 16 and Cyrix republished Intels x86IA32 instruction mnemonics exactly with neither permission nor legal penalty It is doubtful whether in practice many people who programmed the V20 and V30 actually wrote in NECs assembly language rather than Intels since any two assembly languages for the same instruction set architecture are isomorphic somewhat like English and Pig Latin there is no requirement to use a manufacturers own published assembly language with that manufacturers products Language design edit Basic elements edit There is a large degree of diversity in the way the authors of assemblers categorize statements and in the nomenclature that they use In particular some describe anything other than a machine mnemonic or extended mnemonic as a pseudooperation pseudoop A typical assembly language consists of 3 types of instruction statements that are used to define program operations Opcode mnemonics Data definitions Assembly directives Opcode mnemonics and extended mnemonics edit Instructions statements in assembly language are generally very simple unlike those in highlevel languages Generally a mnemonic is a symbolic name for a single executable machine language instruction an opcode and there is at least one opcode mnemonic defined for each machine language instruction Each instruction typically consists of an operation or opcode plus zero or more operands Most instructions refer to a single value or a pair of values Operands can be immediate value coded in the instruction itself registers specified in the instruction or implied or the addresses of data located elsewhere in storage This is determined by the underlying processor architecture the assembler merely reflects how this architecture works Extended mnemonics are often used to specify a combination of an opcode with a specific operand eg the System360 assemblers use B as an extended mnemonic for BC with a mask of 15 and NOP NO OPeration do nothing for one step for BC with a mask of 0 Extended mnemonics are often used to support specialized uses of instructions often for purposes not obvious from the instruction name For example many CPUs do not have an explicit NOP instruction but do have instructions that can be used for the purpose In 8086 CPUs the instruction xchg ax ax is used for nop with nop being a pseudoopcode to encode the instruction xchg ax ax Some disassemblers recognize this and will decode the xchg ax ax instruction as nop Similarly IBM assemblers for System360 and System370 use the extended mnemonics NOP and NOPR for BC and BCR with zero masks For the SPARC architecture these are known as synthetic instructions 17 Some assemblers also support simple builtin macroinstructions that generate two or more machine instructions For instance with some Z80 assemblers the instruction ld hlbc is recognized to generate ld lc followed by ld hb 18 These are sometimes known as pseudoopcodes Mnemonics are arbitrary symbols in 1985 the IEEE published Standard 694 for a uniform set of mnemonics to be used by all assemblers The standard has since been withdrawn Data directives edit There are instructions used to define data elements to hold data and variables They define the type of data the length and the alignment of data These instructions can also define whether the data is available to outside programs programs assembled separately or only to the program in which the data section is defined Some assemblers classify these as pseudoops Assembly directives edit Assembly directives also called pseudoopcodes pseudooperations or pseudoops are commands given to an assembler directing it to perform operations other than assembling instructions 9 Directives affect how the assembler operates and may affect the object code the symbol table the listing file and the values of internal assembler parameters Sometimes the term pseudoopcode is reserved for directives that generate object code such as those that generate data 19 The names of pseudoops often start with a dot to distinguish them from machine instructions Pseudoops can make the assembly of the program dependent on parameters input by a programmer so that one program can be assembled different ways perhaps for different applications Or a pseudoop can be used to manipulate presentation of a program to make it easier to read and maintain Another common use of pseudoops is to reserve storage areas for runtime data and optionally initialize their contents to known values Symbolic assemblers let programmers associate arbitrary names labels or symbols with memory locations and various constants Usually every constant and variable is given a name so instructions can reference those locations by name thus promoting selfdocumenting code In executable code the name of each subroutine is associated with its entry point so any calls to a subroutine can use its name Inside subroutines GOTO destinations are given labels Some assemblers support local symbols which are lexically distinct from normal symbols eg the use of 10 as a GOTO destination Some assemblers such as NASM provide flexible symbol management letting programmers manage different namespaces automatically calculate offsets within data structures and assign labels that refer to literal values or the result of simple computations performed by the assembler Labels can also be used to initialize constants and variables with relocatable addresses Assembly languages like most other computer languages allow comments to be added to program source code that will be ignored during assembly Judicious commenting is essential in assembly language programs as the meaning and purpose of a sequence of binary machine instructions can be difficult to determine The raw uncommented assembly language generated by compilers or disassemblers is quite difficult to read when changes must be made Macros edit Many assemblers support predefined macros and others support programmerdefined and repeatedly redefinable macros involving sequences of text lines in which variables and constants are embedded The macro definition is most commonly a a mixture of assembler statements eg directives symbolic machine instructions and templates for assembler statements This sequence of text lines may include opcodes or directives Once a macro has been defined its name may be used in place of a mnemonic When the assembler processes such a statement it replaces the statement with the text lines associated with that macro then processes them as if they existed in the source code file including in some assemblers expansion of any macros existing in the replacement text Macros in this sense date to IBM autocoders of the 1950s 20 21 In assembly language the term macro represents a more comprehensive concept than it does in some other contexts such as in the C programming language where its define directive typically is used to create short single line macros Assembler macro instructions like macros in PLI and some other languages can be lengthy programs by themselves executed by interpretation by the assembler during assembly Since macros can have short names but expand to several or indeed many lines of code they can be used to make assembly language programs appear to be far shorter requiring fewer lines of source code as with higher level languages They can also be used to add higher levels of structure to assembly programs optionally introduce embedded debugging code via parameters and other similar features Macro assemblers often allow macros to take parameters Some assemblers include quite sophisticated macro languages incorporating such highlevel language elements as optional parameters symbolic variables conditionals string manipulation and arithmetic operations all usable during the execution of a given macro and allowing macros to save context or exchange information Thus a macro might generate numerous assembly language instructions or data definitions based on the macro arguments This could be used to generate recordstyle data structures or unrolled loops for example or could generate entire algorithms based on complex parameters For instance a sort macro could accept the specification of a complex sort key and generate code crafted for that specific key not needing the runtime tests that would be required for a general procedure interpreting the specification An organization using assembly language that has been heavily extended using such a macro suite can be considered to be working in a higherlevel language since such programmers are not working with a computers lowestlevel conceptual elements Underlining this point macros were used to implement an early virtual machine in SNOBOL4 1967 which was written in the SNOBOL Implementation Language SIL an assembly language for a virtual machine The target machine would translate this to its native code using a macro assembler 22 This allowed a high degree of portability for the time Macros were used to customize large scale software systems for specific customers in the mainframe era and were also used by customer personnel to satisfy their employers needs by making specific versions of manufacturer operating systems This was done for example by systems programmers working with IBM s Conversational Monitor System Virtual Machine VMCMS and with IBMs real time transaction processing addons Customer Information Control System CICS and ACP TPF the airlinefinancial system that began in the 1970s and still runs many large computer reservation systems CRS and credit card systems today It is also possible to use solely the macro processing abilities of an assembler to generate code written in completely different languages for example to generate a version of a program in COBOL using a pure macro assembler program containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code IBM OS360 uses macros to perform system generation The user specifies options by coding a series of assembler macros Assembling these macros generates a job stream to build the system including job control language and utility control statements This is because as was realized in the 1960s the concept of macro processing is independent of the concept of assembly the former being in modern terms more word processing text processing than generating object code The concept of macro processing appeared and appears in the C programming language which supports preprocessor instructions to set variables and make conditional tests on their values Note that unlike certain previous macro processors inside assemblers the C preprocessor is not Turingcomplete because it lacks the ability to either loop or go to the latter allowing programs to loop Despite the power of macro processing it fell into disuse in many high level languages major exceptions being C C and PLI while remaining a perennial for assemblers Macro parameter substitution is strictly by name at macro processing time the value of a parameter is textually substituted for its name The most famous class of bugs resulting was the use of a parameter that itself was an expression and not a simple name when the macro writer expected a name In the macro foo macro aload ab the intention was that the caller would provide the name of a variable and the global variable or constant b would be used to multiply a If foo is called with the parameter ac the macro expansion of load acb occurs To avoid any possible ambiguity users of macro processors can parenthesize formal parameters inside macro definitions or callers can parenthesize the input parameters 23 Support for structured programming edit Some assemblers have incorporated structured programming elements to encode execution flow The earliest example of this approach was in the Concept14 macro set originally proposed by Dr Harlan Mills March 1970 and implemented by Marvin Kessler at IBMs Federal Systems Division which extended the S360 macro assembler with IFELSEENDIF and similar control flow blocks 24 This was a way to reduce or eliminate the use of GOTO operations in assembly code one of the main factors causing spaghetti code in assembly language This approach was widely accepted in the early 80s the latter days of largescale assembly language use A curious design was Anatural a streamoriented assembler for 8080 Z80 processors citation needed from Whitesmiths Ltd developers of the Unix like Idris operating system and what was reported to be the first commercial C compiler The language was classified as an assembler because it worked with raw machine elements such as opcodes registers and memory references but it incorporated an expression syntax to indicate execution order Parentheses and other special symbols along with blockoriented structured programming constructs controlled the sequence of the generated instructions Anatural was built as the object language of a C compiler rather than for handcoding but its logical syntax won some fans There has been little apparent demand for more sophisticated assemblers since the decline of largescale assembly language development 25 In spite of that they are still being developed and applied in cases where resource constraints or peculiarities in the target systems architecture prevent the effective use of higherlevel languages 26 Assemblers with a strong macro engine allow structured programming via macros such as the switch macro provided with the Masm32 package note this code is a complete program include masm32 include masm32rtinc use the Masm32 library code demomain REPEAT 20 switch rv nrandom 9 generate a number between 0 and 8 mov ecx 7 case 0 print case 0 case ecx in contrast to most other programming languages print case 7 the Masm32 switch allows variable cases case 1 3 if eax 1 print case 1 elseif eax 2 print case 2 else print cases 1 to 3 other endif case 4 6 8 print cases 4 6 or 8 default mov ebx 19 print 20 stars Repeat print dec ebx Until Si gn loop until the sign flag is set endsw print ch r 13 10 ENDM exit end demomain Use of assembly language edit Historical perspective edit Assembly languages were not available at the time when the storedprogram computer was introduced Kathleen Booth is credited with inventingassembly language 27 28 29 based on theoretical work she began in 1947 while working on the ARC2 at Birkbeck University of London following consultation by Andrew Booth later her husband with mathematician John von Neumann and physicist Herman Goldstine at the Institute for Advanced Study 28 30 In late 1948 the Electronic Delay Storage Automatic Calculator EDSAC had an assembler named initial orders integrated into its bootstrap program It used oneletter mnemonics developed by David Wheeler who is credited by the IEEE Computer Society as the creator of the first assembler 31 32 33 Reports on the EDSAC introduced the term assembly for the process of combining fields into an instruction word 34 SOAP Symbolic Optimal Assembly Program was an assembly language for the IBM 650 computer written by Stan Poley in 1955 35 Assembly languages eliminate much of the errorprone tedious and timeconsuming firstgeneration programming needed with the earliest computers freeing programmers from tedium such as remembering numeric codes and calculating addresses They were once widely used for all sorts of programming However by the 1980s 1990s on microcomputers their use had largely been supplanted by higherlevel languages in the search for improved programming productivity Today assembly language is still used for direct hardware manipulation access to specialized processor instructions or to address critical performance issues Typical uses are device drivers lowlevel embedded systems and realtime systems Historically numerous programs have been written entirely in assembly language The Burroughs MCP 1961 was the first computer for which an operating system was not developed entirely in assembly language it was written in Executive Systems Problem Oriented Language ESPOL an Algol dialect Many commercial applications were written in assembly language as well including a large amount of the IBM mainframe software written by large corporations COBOL FORTRAN and some PLI eventually displaced much of this work although a number of large organizations retained assemblylanguage application infrastructures well into the 1990s Most early microcomputers relied on handcoded assembly language including most operating systems and large applications This was because these systems had severe resource constraints imposed idiosyncratic memory and display architectures and provided limited buggy system services Perhaps more important was the lack of firstclass highlevel language compilers suitable for microcomputer use A psychological factor may have also played a role the first generation of microcomputer programmers retained a hobbyist wires and pliers attitude In a more commercial context the biggest reasons for using assembly language were minimal bloat size minimal overhead greater speed and reliability Typical examples of large assembly language programs from this time are IBM PC DOS operating systems the Turbo Pascal compiler and early applications such as the spreadsheet program Lotus 123 Assembly language was used to get the best performance out of the Sega Saturn a console that was notoriously challenging to develop and program games for 36 The 1993 arcade game NBA Jam is another example Assembly language has long been the primary development language for many popular home computers of the 1980s and 1990s such as the MSX Sinclair ZX Spectrum Commodore 64 Commodore Amiga and Atari ST This was in large part because interpreted BASIC dialects on these systems offered insufficient execution speed as well as insufficient facilities to take full advantage of the available hardware on these systems Some systems even have an integrated development environment IDE with highly advanced debugging and macro facilities Some compilers available for the Radio Shack TRS80 and its successors had the capability to combine inline assembly source with highlevel program statements Upon compilation a builtin assembler produced inline machine code Current usage edit There have always 37 been debates over the usefulness and performance of assembly language relative to highlevel languages Although assembly language has specific niche uses where it is important see below there are other tools for optimization 38 As of July2017 update the TIOBE index of programming language popularity ranks assembly language at 11 ahead of Visual Basic for example 39 Assembler can be used to optimize for speed or optimize for size In the case of speed optimization modern optimizing compilers are claimed 40 to render highlevel languages into code that can run as fast as handwritten assembly despite the counterexamples that can be found 41 42 43 The complexity of modern processors and memory subsystems makes effective optimization increasingly difficult for compilers as well as assembly programmers 44 45 Moreover increasing processor performance has meant that most CPUs sit idle most of the time 46 with delays caused by predictable bottlenecks such as cache misses IO operations and paging This has made raw code execution speed a nonissue for many programmers There are some situations in which developers might choose to use assembly language Writing code for systems with older processors that have limited highlevel language options such as the Atari 2600 Commodore 64 and graphing calculators 47 Code that must interact directly with the hardware for example in device drivers and interrupt handlers In an embedded processor or DSP highrepetition interrupts require the shortest number of cycles per interrupt such as an interrupt that occurs 1000 or 10000 times a second Programs that need to use processorspecific instructions not implemented in a compiler A common example is the bitwise rotation instruction at the core of many encryption algorithms as well as querying the parity of a byte or the 4bit carry of an addition A standalone executable of compact size is required that must execute without recourse to the runtime components or libraries associated with a highlevel language Examples have included firmware for telephones automobile fuel and ignition systems airconditioning control systems security systems and sensors Programs with performancesensitive inner loops where assembly language provides optimization opportunities that are difficult to achieve in a highlevel language For example linear algebra with BLAS 41 48 or discrete cosine transformation eg SIMD assembly version from x264 49 Programs that create vectorized functions for programs in higherlevel languages such as C In the higherlevel language this is sometimes aided by compiler intrinsic functions which map directly to SIMD mnemonics but nevertheless result in a onetoone assembly conversion specific for the given vector processor Realtime programs such as simulations flight navigation systems and medical equipment For example in a flybywire system telemetry must be interpreted and acted upon within strict time constraints Such systems must eliminate sources of unpredictable delays which may be created by some interpreted languages automatic garbage collection paging operations or preemptive multitasking However some higherlevel languages incorporate runtime components and operating system interfaces that can introduce such delays Choosing assembly or lower level languages for such systems gives programmers greater visibility and control over processing details Cryptographic algorithms that must always take strictly the same time to execute preventing timing attacks Modify and extend legacy code written for IBM mainframe computers 50 Situations where complete control over the environment is required in extremely high security situations where nothing can be taken for granted Computer viruses bootloaders certain device drivers or other items very close to the hardware or lowlevel operating system Instruction set simulators for monitoring tracing and debugging where additional overhead is kept to a minimum Situations where no highlevel language exists on a new or specialized processor for which no cross compiler is available Reverseengineering and modifying program files such as existing binaries that may or may not have originally been written in a highlevel language for example when trying to recreate programs for which source code is not available or has been lost or cracking copy protection of proprietary software Video games also termed ROM hacking which is possible via several methods The most widely employed method is altering program code at the assembly language level Assembly language is still taught in most computer science and electronic engineering programs Although few programmers today regularly work with assembly language as a tool the underlying concepts remain important Such fundamental topics as binary arithmetic memory allocation stack processing character set encoding interrupt processing and compiler design would be hard to study in detail without a grasp of how a computer operates at the hardware level Since a computers behavior is fundamentally defined by its instruction set the logical way to learn such concepts is to study an assembly language Most modern computers have similar instruction sets Therefore studying a single assembly language is sufficient to learn I the basic concepts II to recognize situations where the use of assembly language might be appropriate and III to see how efficient executable code can be created from highlevel languages 51 Typical applications edit Assembly language is typically used in a systems boot code the lowlevel code that initializes and tests the system hardware prior to booting the operating system and is often stored in ROM BIOS on IBMcompatible PC systems and CPM is an example Some compilers translate highlevel languages into assembly first before fully compiling allowing the assembly code to be viewed for debugging and optimization purposes Some compilers for relatively lowlevel languages such as Pascal or C allow the programmer to embed assembly language directly in the source code Programs using such facilities can then construct abstractions using different assembly language on each hardware platform The systems portable code can then use these processorspecific components through a uniform interface Assembly language is useful in reverse engineering Many programs are distributed only in machine code form which is straightforward to translate into assembly language but more difficult to translate into a higherlevel language Tools such as the Interactive Disassembler make extensive use of disassembly for such a purpose This technique is used by hackers to crack commercial software and competitors to produce software with similar results from competing companies Assembly language is used to enhance speed of execution especially in early Personal Computers with limited processing power and RAM Assemblers can be used to generate blocks of data with no highlevel language overhead from formatted and commented source code to be used by other code See also edit Computer programming portal Compiler Comparison of assemblers Disassembler Hexadecimal Instruction set Little man computer an educational computer model with a base10 assembly language Nibble Typed assembly language Notes edit In 7070 Autocoder a macro definition is a 7070 macro generator program that the assembler calls Autocoder provides special macros for macro generators to use References edit a b Assembler language mwparseroutput citecitationfontstyleinheritmwparseroutput citation qquotesmwparseroutput citation cs1lockfree abackgroundurluploadwikimediaorgwikipediacommonsthumb665Lockgreensvg9pxLockgreensvgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locklimited amwparseroutput citation cs1lockregistration abackgroundurluploadwikimediaorgwikipediacommonsthumbdd6Lockgrayalt2svg9pxLockgrayalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locksubscription abackgroundurluploadwikimediaorgwikipediacommonsthumbaaaLockredalt2svg9pxLockredalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput cs1subscriptionmwparseroutput cs1registrationcolor555mwparseroutput cs1subscription spanmwparseroutput cs1registration spanborderbottom1px dottedcursorhelpmwparseroutput cs1wsicon abackgroundurluploadwikimediaorgwikipediacommonsthumb44cWikisourcelogosvg12pxWikisourcelogosvgpngnorepeatbackgroundpositionright 1em centermwparseroutput codecs1codecolorinheritbackgroundinheritborderinheritpaddinginheritmwparseroutput cs1hiddenerrordisplaynonefontsize100mwparseroutput cs1visibleerrorfontsize100mwparseroutput cs1maintdisplaynonecolor33aa33marginleft03emmwparseroutput cs1subscriptionmwparseroutput cs1registrationmwparseroutput cs1formatfontsize95mwparseroutput cs1kernleftmwparseroutput cs1kernwlleftpaddingleft02emmwparseroutput cs1kernrightmwparseroutput cs1kernwlrightpaddingright02em James Saxon William Plette 1962 Programming the IBM 1401 PrenticeHall LCCN 6220615 via HathiTrust use of the term assembly program Assembly Review The Ohio State University PDF 2016 B Archer Assembly Language For Students Assembly language may also be called symbolic machine code High Level Assembler Opcodes overview Assembler Directives Macro instructions System calls often vary eg for MVS vs VSE vs VMCMS the binaryexecutable formats for different operating systems may also vary How do assembly languages depend on operating systems John Daintith ed A Dictionary of Computing metaassembler a b David Salomon 1993 Assemblers and Loaders Beck Leland L 1996 2 System Software An Introduction to Systems Programming Addison Wesley Hyde Randall Chapter 12 Classes and Objects The Art of Assembly Language 2nd Edition No Starch Press 2010 Intel Architecture Software Developers Manual Volume 2 Instruction Set Reference PDF Intel Corporation 1999 Retrieved 18 November 2010 a b c Intel Architecture Software Developers Manual Volume 2 Instruction Set Reference PDF Intel Corporation 1999 pp442 and 35 Retrieved 18 November 2010 Actually this is one of two redundant forms of this instruction that operate identically The 8086 and several other CPUs from the late 1970searly 1980s have redundancies in their instruction sets because it was simpler for engineers to design these CPUs to fit on silicon chips of limited sizes with the redundant codes than to eliminate them Each assembler will typically generate only one of two or more redundant instruction encodings but a disassembler will usually recognize any of them Evans David 2006 x86 Assembly Guide University of Virginia Retrieved 18 November 2010 Note AMD manufactured secondsource Intel 8086 8088 and 80286 CPUs and perhaps 8080A andor 8085A CPUs under license from Intel but starting with the 80386 Intel refused to share their x86 CPU designs with anyoneAMD sued about this for breach of contractand AMD designed made and sold 32bit and 64bit x86family CPUs without Intels help or endorsement The SPARC Architecture Manual Version 8 PDF SPARC International 1992 Archived from the original PDF on 20111210 Z80 Op Codes for ZINT Z80de Retrieved on 20130721 Microsoft Corporation MASM Directives PseudoOpcodes PDF Retrieved March 19 2011 Users of 1401 Autocoder The following minor restriction or limitation is in effect with regard to the use of 1401 Autocoder when coding macro instructions Griswold Ralph E The Macro Implementation of SNOBOL4 San Francisco CA W H Freeman and Company 1972 ISBN 0716704471 Chapter 1 Macros CC MSDN Library for Visual Studio 2008 Microsoft Corp Retrieved 20100622 Concept 14 Macros MVS Software Retrieved May 25 2009 Answerscom assembly language Definition and Much More from Answerscom Retrieved 20080619 Provinciano Brian NESHLA The High Level Open Source 6502 Assembler for the Nintendo Entertainment System Kathleen Booth Assembling Early Computers While Inventing Assembly Retrieved February 10 2019 a b Andrew D Booth Kathleen H V Britten September 1947 General considerations in the design of an all purpose electronic digital computer Coding for the ARC 2nd ed PDF Birkbeck College London Retrieved 10 February 2019 The nonoriginal ideas contained in the following text have been derived from a number of sources It is felt however that acknowledgement should be made to Prof John von Neumann and to Dr Herman Goldstein for many fruitful discussions see TALK page for details CampbellKelly Martin April 1982 The Development of Computer Programming in Britain 1945 to 1955 IEEE Annals of the History of Computing 4 2 121139 doi 101109MAHC198210016 Salomon Assemblers and Loaders PDF p7 Retrieved 20120117 CampbellKelly Martin 1980 Programming the EDSAC IEEE Annals of the History of Computing 2 1 736 doi 101109MAHC198010009 httpswwwcomputerorgwebawardspioneerdavidwheeler 1985 Computer Pioneer Award For assembly language programming David Wheeler Wilkes Maurice V 1949 The EDSAC an Electronic Calculating Machine Journal of Scientific Instruments 26 12 385391 doi 101088095076712612301 The IBM 650 Magnetic Drum Calculator Retrieved 20120117 Eidolons Inn SegaBase Saturn Archived from the original on 20080713 Retrieved 20080725 Barry Kauler 1997 Windows Assembly Language and Systems Programming 16 and 32Bit ISBN 9781482275728 Always the debate rages about the applicability of assembly language in our modern programming world Paul Hsieh Programming Optimization design changes tend to affect performance more than one should not skip straight to assembly language until TIOBE Index TIOBE Software Rusling David A The Linux Kernel Retrieved Mar 11 2012 a b Writing the Fastest Code by Hand for Fun A Human Computer Keeps Speeding Up Chips New York Times John Markoff 20051128 Retrieved 20100304 Bitfieldbadness hardwarebugorg 20100130 Archived from the original on 20100205 Retrieved 20100304 GCC makes a mess HardwareBugorg 20090513 Archived from the original on 20100316 Retrieved 20100304 Randall Hyde The Great Debate Archived from the original on 20080616 Retrieved 20080703 Code sourcery fails again hardwarebugorg 20100130 Archived from the original on 20100402 Retrieved 20100304 Click Cliff A Crash Course in Modern Hardware Retrieved May 1 2014 68K Programming in Fargo II Archived from the original on 2 July 2008 Retrieved 20080703 BLAS BenchmarkAugust2008 eigentuxfamilyorg 20080801 Retrieved 20100304 x264gitcommonx86dct32asm gitvideolanorg 20100929 Archived from the original on 20120304 Retrieved 20100929 Chapter 1 Why Study Assembly Language wwwedwardbosworthcom Retrieved 20160601 Hyde Randall 19960930 Foreword Why would anyone learn this stuff op cit Archived from the original on 20100325 Retrieved 20100305 Further reading edit ASM Community Book An online book full of helpful ASM info tutorials and code examples by the ASM Community archived at the internet archive Jonathan Bartlett Programming from the Ground Up Bartlett Publishing 2004 ISBN 0975283847 Also available online as PDF Robert Britton MIPS Assembly Language Programming Prentice Hall 2003 ISBN 0131420445 Jeff Duntemann Assembly Language StepbyStep Wiley 2000 ISBN 0471375233 Randall Hyde The Art of Assembly Language No Starch Press 2003 ISBN 1886411972 Draft versions available online as PDF and HTML Charles W Kann Introduction to MIPS Assembly Language Programming 2015 Peter Norton John Socha Peter Nortons Assembly Language Book for the IBM PC Brady Books NY 1986 Michael Singer PDP11 Assembler Language Programming and Machine Organization John Wiley Sons NY 1980 Dominic Sweetman See MIPS Run Morgan Kaufmann Publishers 1999 ISBN 1558604103 John Waldron Introduction to RISC Assembly Language Programming Addison Wesley 1998 ISBN 0201398281 Dennis Yurichev Understanding Assembly Language External links edit Assembly language at Wikipedias sister projects Definitions from Wiktionary Media from Wikimedia Commons News from Wikinews Textbooks from Wikibooks Resources from Wikiversity Assembly language at Curlie Unix Assembly Language Programming Linux Assembly PPR Learning Assembly Language NASM The Netwide Assembler a popular assembly language Assembly Language Programming Examples Authoring Windows Applications In Assembly Language Assembly Optimization Tips by Mark Larson The Art of Assembly Language by Randall Hyde The table for assembly language to machine code v t e Types of programming languages Actorbased Array Aspectoriented Classbased Concatenative Concurrent Dataflow Declarative Domainspecific Dynamic Esoteric Eventdriven Extensible Functional Imperative Logic Macro Metaprogramming Multiparadigm Objectbased Objectoriented Pipeline Procedural Prototypebased Reflective Rulebased Scripting Stack based Synchronous Tactile Templating Assembly Compiled Interpreted Machine Lowlevel Highlevel Very highlevel First generation Second generation Third generation Fourth generation Fifth generation NonEnglishbased Visual v t e Programming languages Comparison Timeline History APL Assembly BASIC C C C COBOL Elixir Fortran Go Groovy Haskell Java JavaScript JS Julia Kotlin Lisp Lua MATLAB ObjectiveC OCaml Pascal Perl PHP Python R Ruby Rust Scala Shell Smalltalk Swift TypeScript Visual Basic NET VBNET more Category Lists Alphabetical Categorical Generational NonEnglishbased v t e Embedded systems General terms ASIC Board support package Bootloader Consumer electronics Cross compiler Embedded database Embedded hypervisor Embedded OS Embedded software FPGA IoT Memory footprint Microcontroller Singleboard computer Raspberry Pi SoC Firmware and controls Closed platform Crippleware Custom firmware Defective by Design Hacking of consumer electronics Homebrew video games iOS jailbreaking PlayStation 3 Jailbreak Proprietary firmware Rooting Android Vendor lockin Software libraries uClibc dietlibc Embedded GLIBC lwIP musl Programming tools Almquist shell Bitbake Buildroot BusyBox OpenEmbedded Standalone shell Toybox Yocto Project Operating systems Linux on embedded systems Linux for mobile devices Lightweight Linux distribution Realtime operating system Windows IoT Win CE Programming languages Ada Assembly language CAPL Embedded C Embedded C Embedded Java MISRA C Lightweight browsers Opensource computing hardware Opensource robotics Authority control BNF cb11961749m data GND 40032553 LCCN sh85008765