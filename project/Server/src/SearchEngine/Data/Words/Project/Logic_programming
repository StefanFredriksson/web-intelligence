Logic programming RuleBased redirects here For the method of machine translation see Rulebased machine translation For methods of machine learning see Rulebased machine learning Programming paradigms Action Agentoriented Arrayoriented Automatabased Concurrent computing Relativistic programming Datadriven Declarative contrast Imperative Functional Functional logic Purely functional Logic Abductive logic Answer set Concurrent logic Functional logic Inductive logic Constraint Constraint logic Concurrent constraint logic Dataflow Flowbased Reactive Ontology Differentiable Dynamicscripting Eventdriven Functionlevel contrast Valuelevel Pointfree style Concatenative Generic Imperative contrast Declarative Procedural Objectoriented Polymorphic Intentional Languageoriented Domainspecific Literate Naturallanguage programming Metaprogramming Automatic Inductive programming Reflective Attributeoriented Macro Template Nonstructured contrast Structured Array Nondeterministic Parallel computing Processoriented Probabilistic Quantum Settheoretic Stackbased Structured contrast Nonstructured Blockstructured Structured concurrency Objectoriented Actorbased Classbased Concurrent Prototypebased By separation of concerns Aspectoriented Roleoriented Subjectoriented Recursive Symbolic Valuelevel contrast Functionlevel v t e Logic programming is a type of programming paradigm which is largely based on formal logic Any program written in a logic programming language is a set of sentences in logical form expressing facts and rules about some problem domain Major logic programming language families include Prolog answer set programming ASP and Datalog In all of these languages rules are written in the form of clauses H B 1 B n and are read declaratively as logical implications H if B 1 and and B n H is called the head of the rule and B 1 B n is called the body Facts are rules that have no body and are written in the simplified form H In the simplest case in which H B 1 B n are all atomic formulae these clauses are called definite clauses or Horn clauses However there exist many extensions of this simple case the most important one being the case in which conditions in the body of a clause can also be negations of atomic formulae Logic programming languages that include this extension have the knowledge representation capabilities of a nonmonotonic logic In ASP and Datalog logic programs have only a declarative reading and their execution is performed by means of a proof procedure or model generator whose behaviour is not meant to be under the control of the programmer However in the Prolog family of languages logic programs also have a procedural interpretation as goalreduction procedures to solve H solve B 1 and and solve B n Consider for example the following clause fallibleX humanX based on an example used by Terry Winograd 1 to illustrate the programming language Planner As a clause in a logic program it can be used both as a procedure to test whether X is fallible by testing whether X is human and as a procedure to find an X that is fallible by finding an X that is human Even facts have a procedural interpretation For example the clause humansocrates can be used both as a procedure to show that socrates is human and as a procedure to find an X that is human by assigning socrates to X The declarative reading of logic programs can be used by a programmer to verify their correctness Moreover logicbased program transformation techniques can also be used to transform logic programs into logically equivalent programs that are more efficient In the Prolog family of logic programming languages the programmer can also use the known problemsolving behaviour of the execution mechanism to improve the efficiency of programs Contents 1 History 2 Concepts 21 Logic and control 22 Problem solving 23 Negation as failure 24 Knowledge representation 3 Variants and extensions 31 Prolog 32 Abductive logic programming 33 Metalogic programming 34 Constraint logic programming 35 Concurrent logic programming 36 Concurrent constraint logic programming 37 Inductive logic programming 38 Higherorder logic programming 39 Linear logic programming 310 Objectoriented logic programming 311 Transaction logic programming 4 See also 5 References 51 Citations 52 General introductions 53 Other sources 6 Further reading 7 External links History edit The use of mathematical logic to represent and execute computer programs is also a feature of the lambda calculus developed by Alonzo Church in the 1930s However the first proposal to use the clausal form of logic for representing computer programs was made by Cordell Green 2 This used an axiomatization of a subset of LISP together with a representation of an inputoutput relation to compute the relation by simulating the execution of the program in LISP Foster and Elcocks Absys on the other hand employed a combination of equations and lambda calculus in an assertional programming language which places no constraints on the order in which operations are performed 3 Logic programming in its present form can be traced back to debates in the late 1960s and early 1970s about declarative versus procedural representations of knowledge in artificial intelligence Advocates of declarative representations were notably working at Stanford associated with John McCarthy Bertram Raphael and Cordell Green and in Edinburgh with John Alan Robinson an academic visitor from Syracuse University Pat Hayes and Robert Kowalski Advocates of procedural representations were mainly centered at MIT under the leadership of Marvin Minsky and Seymour Papert citation needed Although it was based on the proof methods of logic Planner developed at MIT was the first language to emerge within this proceduralist paradigm 4 Planner featured patterndirected invocation of procedural plans from goals ie goalreduction or backward chaining and from assertions ie forward chaining The most influential implementation of Planner was the subset of Planner called MicroPlanner implemented by Gerry Sussman Eugene Charniak and Terry Winograd It was used to implement Winograds naturallanguage understanding program SHRDLU which was a landmark at that time 1 To cope with the very limited memory systems at the time Planner used a backtracking control structure so that only one possible computation path had to be stored at a time Planner gave rise to the programming languages QA4 Popler Conniver QLISP and the concurrent language Ether citation needed Hayes and Kowalski in Edinburgh tried to reconcile the logicbased declarative approach to knowledge representation with Planners procedural approach Hayes 1973 developed an equational language Golux in which different procedures could be obtained by altering the behavior of the theorem prover 5 Kowalski on the other hand developed SLD resolution 6 a variant of SLresolution 7 and showed how it treats implications as goalreduction procedures Kowalski collaborated with Colmerauer in Marseille who developed these ideas in the design and implementation of the programming language Prolog The Association for Logic Programming was founded to promote Logic Programming in 1986 Prolog gave rise to the programming languages ALF Fril Gödel Mercury Oz Ciao Visual Prolog XSB and λProlog as well as a variety of concurrent logic programming languages 8 constraint logic programming languages and Datalog 9 Concepts edit Logic and control edit Main article Declarative programming Logic programming can be viewed as controlled deduction An important concept in logic programming is the separation of programs into their logic component and their control component With pure logic programming languages the logic component alone determines the solutions produced The control component can be varied to provide alternative ways of executing a logic program This notion is captured by the slogan Algorithm Logic Control where Logic represents a logic program and Control represents different theoremproving strategies 10 Problem solving edit In the simplified propositional case in which a logic program and a toplevel atomic goal contain no variables backward reasoning determines an andor tree which constitutes the search space for solving the goal The toplevel goal is the root of the tree Given any node in the tree and any clause whose head matches the node there exists a set of child nodes corresponding to the subgoals in the body of the clause These child nodes are grouped together by an and The alternative sets of children corresponding to alternative ways of solving the node are grouped together by an or Any search strategy can be used to search this space Prolog uses a sequential lastinfirstout backtracking strategy in which only one alternative and one subgoal is considered at a time Other search strategies such as parallel search intelligent backtracking or bestfirst search to find an optimal solution are also possible In the more general case where subgoals share variables other strategies can be used such as choosing the subgoal that is most highly instantiated or that is sufficiently instantiated so that only one procedure applies Such strategies are used for example in concurrent logic programming Negation as failure edit Main article Negation as failure For most practical applications as well as for applications that require nonmonotonic reasoning in artificial intelligence Horn clause logic programs need to be extended to normal logic programs with negative conditions A clause in a normal logic program has the form H A 1 A n not B 1 not B n and is read declaratively as a logical implication H if A 1 and and A n and not B 1 and and not B n where H and all the A i and B i are atomic formulas The negation in the negative literals not B i is commonly referred to as negation as failure because in most implementations a negative condition not B i is shown to hold by showing that the positive condition B i fails to hold For example canfly X bird X not abnormal X abnormal X wounded X bird john bird mary wounded john Given the goal of finding something that can fly canfly X there are two candidate solutions which solve the first subgoal birdX namely X john and X mary The second subgoal not abnormaljohn of the first candidate solution fails because woundedjohn succeeds and therefore abnormaljohn succeeds However The second subgoal not abnormalmary of the second candidate solution succeeds because woundedmary fails and therefore abnormalmary fails Therefore X mary is the only solution of the goal MicroPlanner had a construct called thnot which when applied to an expression returns the value true if and only if the evaluation of the expression fails An equivalent operator is normally builtin in modern Prolog s implementations It is normally written as not Goal or Goal where Goal is some goal proposition to be proved by the program This operator differs from negation in firstorder logic a negation such as X 1 fails when the variable X has been bound to the atom 1 but it succeeds in all other cases including when X is unbound This makes Prologs reasoning nonmonotonic X 1 X 1 always fails while X 1 X 1 can succeed binding X to 1 depending on whether X was initially bound note that standard Prolog executes goals in lefttoright order The logical status of negation as failure was unresolved until Keith Clark 1978 showed that under certain natural conditions it is a correct and sometimes complete implementation of classical negation with respect to the completion of the program Completion amounts roughly to regarding the set of all the program clauses with the same predicate on the left hand side say H Body 1 H Body k as a definition of the predicate H iff Body 1 or or Body k where iff means if and only if Writing the completion also requires explicit use of the equality predicate and the inclusion of a set of appropriate axioms for equality However the implementation of negation by failure needs only the ifhalves of the definitions without the axioms of equality For example the completion of the program above is canflyX iff birdX not abnormalX abnormalX iff woundedX birdX iff X john or X mary X X not john mary not mary john The notion of completion is closely related to McCarthys circumscription semantics for default reasoning and to the closed world assumption As an alternative to the completion semantics negation as failure can also be interpreted epistemically as in the stable model semantics of answer set programming In this interpretation notB i means literally that B i is not known or not believed The epistemic interpretation has the advantage that it can be combined very simply with classical negation as in extended logic programming to formalise such phrases as the contrary can not be shown where contrary is classical negation and can not be shown is the epistemic interpretation of negation as failure Knowledge representation edit The fact that Horn clauses can be given a procedural interpretation and vice versa that goalreduction procedures can be understood as Horn clauses backward reasoning means that logic programs combine declarative and procedural representations of knowledge The inclusion of negation as failure means that logic programming is a kind of nonmonotonic logic Despite its simplicity compared with classical logic this combination of Horn clauses and negation as failure has proved to be surprisingly expressive For example it provides a natural representation for the commonsense laws of cause and effect as formalised by both the situation calculus and event calculus It has also been shown to correspond quite naturally to the semiformal language of legislation In particular Prakken and Sartor 11 credit the representation of the British Nationality Act as a logic program 12 with being hugely influential for the development of computational representations of legislation showing how logic programming enables intuitively appealing representations that can be directly deployed to generate automatic inferences Variants and extensions edit Prolog edit Main article Prolog The programming language Prolog was developed in 1972 by Alain Colmerauer It emerged from a collaboration between Colmerauer in Marseille and Robert Kowalski in Edinburgh Colmerauer was working on natural language understanding using logic to represent semantics and using resolution for questionanswering During the summer of 1971 Colmerauer and Kowalski discovered that the clausal form of logic could be used to represent formal grammars and that resolution theorem provers could be used for parsing They observed that some theorem provers like hyperresolution behave as bottomup parsers and others like SLresolution 1971 behave as topdown parsers It was in the following summer of 1972 that Kowalski again working with Colmerauer developed the procedural interpretation of implications This dual declarativeprocedural interpretation later became formalised in the Prolog notation H B 1 B n which can be read and used both declaratively and procedurally It also became clear that such clauses could be restricted to definite clauses or Horn clauses where H B 1 B n are all atomic predicate logic formulae and that SLresolution could be restricted and generalised to LUSH or SLDresolution Kowalskis procedural interpretation and LUSH were described in a 1973 memo published in 1974 6 Colmerauer with Philippe Roussel used this dual interpretation of clauses as the basis of Prolog which was implemented in the summer and autumn of 1972 The first Prolog program also written in 1972 and implemented in Marseille was a French questionanswering system The use of Prolog as a practical programming language was given great momentum by the development of a compiler by David Warren in Edinburgh in 1977 Experiments demonstrated that Edinburgh Prolog could compete with the processing speed of other symbolic programming languages such as Lisp Edinburgh Prolog became the de facto standard and strongly influenced the definition of ISO standard Prolog Abductive logic programming edit Abductive logic programming is an extension of normal Logic Programming that allows some predicates declared as abducible predicates to be open or undefined A clause in an abductive logic program has the form H B 1 B n A 1 A n where H is an atomic formula that is not abducible all the B i are literals whose predicates are not abducible and the A i are atomic formulas whose predicates are abducible The abducible predicates can be constrained by integrity constraints which can have the form false L 1 L n where the L i are arbitrary literals defined or abducible and atomic or negated For example canfly X bird X normal X false normal X wounded X bird john bird mary wounded john where the predicate normal is abducible Problem solving is achieved by deriving hypotheses expressed in terms of the abducible predicates as solutions of problems to be solved These problems can be either observations that need to be explained as in classical abductive reasoning or goals to be solved as in normal logic programming For example the hypothesis normalmary explains the observation canflymary Moreover the same hypothesis entails the only solution X mary of the goal of finding something that can fly canfly X Abductive logic programming has been used for fault diagnosis planning natural language processing and machine learning It has also been used to interpret Negation as Failure as a form of abductive reasoning Metalogic programming edit Because mathematical logic has a long tradition of distinguishing between object language and metalanguage logic programming also allows metalevel programming The simplest metalogic program is the socalled vanilla metainterpreter solve true solve A B solve A solve B solve A clause A B solve B where true represents an empty conjunction and clauseAB means there is an objectlevel clause of the formA B Metalogic programming allows objectlevel and metalevel representations to be combined as in natural language It can also be used to implement any logic that is specified by means of inference rules Metalogic is used in logic programming to implement metaprograms which manipulate other programs databases knowledge bases or axiomatic theories as data Constraint logic programming edit Main article Constraint logic programming Constraint logic programming combines Horn clause logic programming with constraint solving It extends Horn clauses by allowing some predicates declared as constraint predicates to occur as literals in the body of clauses A constraint logic program is a set of clauses of the form H C 1 C n B 1 B n where H and all the B i are atomic formulas and the C i are constraints Declaratively such clauses are read as ordinary logical implications H if C 1 and and C n and B 1 and and B n However whereas the predicates in the heads of clauses are defined by the constraint logic program the predicates in the constraints are predefined by some domainspecific modeltheoretic structure or theory Procedurally subgoals whose predicates are defined by the program are solved by goalreduction as in ordinary logic programming but constraints are checked for satisfiability by a domainspecific constraintsolver which implements the semantics of the constraint predicates An initial problem is solved by reducing it to a satisfiable conjunction of constraints The following constraint logic program represents a toy temporal database of johns history as a teacher teaches john hardware T 1990 T T 1999 teaches john software T 1999 T T 2005 teaches john logic T 2005 T T 2012 rank john instructor T 1990 T T 2010 rank john professor T 2010 T T 2014 Here and are constraint predicates with their usual intended semantics The following goal clause queries the database to find out when john both taught logic and was a professor teachesjohn logic T rankjohn professor T The solution is 2010 T T 2012 Constraint logic programming has been used to solve problems in such fields as civil engineering mechanical engineering digital circuit verification automated timetabling air traffic control and finance It is closely related to abductive logic programming Concurrent logic programming edit Main article Concurrent logic programming Concurrent logic programming integrates concepts of logic programming with concurrent programming Its development was given a big impetus in the 1980s by its choice for the systems programming language of the Japanese Fifth Generation Project FGCS 13 A concurrent logic program is a set of guarded Horn clauses of the form H G 1 G n B 1 B n The conjunction G 1 G n is called the guard of the clause and is the commitment operator Declaratively guarded Horn clauses are read as ordinary logical implications H if G 1 and and G n and B 1 and and B n However procedurally when there are several clauses whose heads H match a given goal then all of the clauses are executed in parallel checking whether their guards G 1 G n hold If the guards of more than one clause hold then a committed choice is made to one of the clauses and execution proceeds with the subgoals B 1 B n of the chosen clause These subgoals can also be executed in parallel Thus concurrent logic programming implements a form of dont care nondeterminism rather than dont know nondeterminism For example the following concurrent logic program defines a predicate shuffleLeft Right Merge which can be used to shuffle two lists Left and Right combining them into a single list Merge that preserves the ordering of the two lists Left and Right shuffle shuffle Left Right Merge Left First Rest Merge First ShortMerge shuffle Rest Right ShortMerge shuffle Left Right Merge Right First Rest Merge First ShortMerge shuffle Left Rest ShortMerge Here represents the empty list and Head Tail represents a list with first element Head followed by list Tail as in Prolog Notice that the first occurrence of in the second and third clauses is the list constructor whereas the second occurrence of is the commitment operator The program can be used for example to shuffle the lists ace queen king and 1 4 2 by invoking the goal clause shuffle ace queen king 1 4 2 Merge The program will nondeterministically generate a single solution for example Merge ace queen 1 king 4 2 Arguably concurrent logic programming is based on message passing and consequently is subject to the same indeterminacy as other concurrent messagepassing systems such as Actors see Indeterminacy in concurrent computation Carl Hewitt has argued that concurrent logic programming is not based on logic in his sense that computational steps cannot be logically deduced 14 However in concurrent logic programming any result of a terminating computation is a logical consequence of the program and any partial result of a partial computation is a logical consequence of the program and the residual goal process network Consequently the indeterminacy of computations implies that not all logical consequences of the program can be deduced neutrality is disputed Concurrent constraint logic programming edit Main article Concurrent constraint logic programming Concurrent constraint logic programming combines concurrent logic programming and constraint logic programming using constraints to control concurrency A clause can contain a guard which is a set of constraints that may block the applicability of the clause When the guards of several clauses are satisfied concurrent constraint logic programming makes a committed choice to the use of only one Inductive logic programming edit Main article Inductive logic programming Inductive logic programming is concerned with generalizing positive and negative examples in the context of background knowledge machine learning of logic programs Recent work in this area combining logic programming learning and probability has given rise to the new field of statistical relational learning and probabilistic inductive logic programming Higherorder logic programming edit Several researchers have extended logic programming with higherorder programming features derived from higherorder logic such as predicate variables Such languages include the Prolog extensions HiLog and λProlog Linear logic programming edit Basing logic programming within linear logic has resulted in the design of logic programming languages that are considerably more expressive than those based on classical logic Horn clause programs can only represent state change by the change in arguments to predicates In linear logic programming one can use the ambient linear logic to support state change Some early designs of logic programming languages based on linear logic include LO Andreoli Pareschi 1991 Lolli 15 ACL 16 and Forum Miller 1996 Forum provides a goaldirected interpretation of all of linear logic Objectoriented logic programming edit Flogic extends logic programming with objects and the frame syntax Logtalk extends the Prolog programming language with support for objects protocols and other OOP concepts Highly portable it supports most standardcompliant Prolog systems as backend compilers Transaction logic programming edit Transaction logic is an extension of logic programming with a logical theory of statemodifying updates It has both a modeltheoretic semantics and a procedural one An implementation of a subset of Transaction logic is available in the Flora2 system Other prototypes are also available See also edit Automated theorem proving Boolean satisfiability problem Constraint logic programming Datalog Fril Functional programming Fuzzy logic Inductive logic programming Logic in computer science includes Formal methods Logic programming languages Programming paradigm R Reasoning system Rulebased machine learning Satisfiability Linear logic References edit Citations edit This article includes a list of references but its sources remain unclear because it has insufficient inline citations Please help to improve this article by introducing more precise citations February 2012 Learn how and when to remove this template message a b T Winograd 1972 Understanding natural language Cognitive Psychology 3 1 1191 doi 1010160010028572900023 mwparseroutput citecitationfontstyleinheritmwparseroutput citation qquotesmwparseroutput citation cs1lockfree abackgroundurluploadwikimediaorgwikipediacommonsthumb665Lockgreensvg9pxLockgreensvgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locklimited amwparseroutput citation cs1lockregistration abackgroundurluploadwikimediaorgwikipediacommonsthumbdd6Lockgrayalt2svg9pxLockgrayalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput citation cs1locksubscription abackgroundurluploadwikimediaorgwikipediacommonsthumbaaaLockredalt2svg9pxLockredalt2svgpngnorepeatbackgroundpositionright 1em centermwparseroutput cs1subscriptionmwparseroutput cs1registrationcolor555mwparseroutput cs1subscription spanmwparseroutput cs1registration spanborderbottom1px dottedcursorhelpmwparseroutput cs1wsicon abackgroundurluploadwikimediaorgwikipediacommonsthumb44cWikisourcelogosvg12pxWikisourcelogosvgpngnorepeatbackgroundpositionright 1em centermwparseroutput codecs1codecolorinheritbackgroundinheritborderinheritpaddinginheritmwparseroutput cs1hiddenerrordisplaynonefontsize100mwparseroutput cs1visibleerrorfontsize100mwparseroutput cs1maintdisplaynonecolor33aa33marginleft03emmwparseroutput cs1subscriptionmwparseroutput cs1registrationmwparseroutput cs1formatfontsize95mwparseroutput cs1kernleftmwparseroutput cs1kernwlleftpaddingleft02emmwparseroutput cs1kernrightmwparseroutput cs1kernwlrightpaddingright02em Cordell Green Application of Theorem Proving to Problem Solving IJCAI 1969 JM Foster and EW Elcock ABSYS 1 An Incremental Compiler for Assertions an Introduction Machine Intelligence 4 Edinburgh U Press 1969 pp423429 Carl Hewitt Planner A Language for Proving Theorems in Robots IJCAI 1969 Pat Hayes Computation and Deduction In Proceedings of the 2nd MFCS Symposium Czechoslovak Academy of Sciences 1973 pp105118 a b Robert Kowalski Predicate Logic as a Programming Language Memo 70 Department of Artificial Intelligence Edinburgh University 1973 Also in Proceedings IFIP Congress Stockholm North Holland Publishing Co 1974 pp569574 Robert Kowalski and Donald and Kuehner Linear Resolution with Selection Function Artificial Intelligence Vol 2 1971 pp22760 Shapiro Ehud 1989 The family of concurrent logic programming languages PDF International Summer School on Logic Algebra and Computation Also appeared in Shapiro E 1989 The family of concurrent logic programming languages ACM Computing Surveys 21 3 413510 doi 1011457255172555 SáenzPerez Fernando Caballero Rafael GarcíaRuiz Yolanda December 2011 A Deductive Database with Datalog and SQL Query Language Asian Symposium on Programming Languages and Systems Springer pp6673 RAKowalski July 1979 AlgorithmLogic Control Communications of the ACM 22 7 424436 doi 101145359131359136 Prakken H and Sartor G 2015 Law and logic a review from an argumentation perspective Artificial Intelligence 227 214245 Sergot MJ Sadri F Kowalski RA Kriwaczek F Hammond P and Cory HT 1986 The British Nationality Act as a logic program Communications of the ACM 295 370386 Shunichi Uchida and Kazuhiro Fuchi Proceedings of the FGCS Project Evaluation Workshop Institute for New Generation Computer Technology ICOT 1992 Hewitt Carl 27 April 2016 Inconsistency Robustness for Logic Programs Hal Archives pp2126 Retrieved 7 November 2016 Joshua Hodas and Dale Miller Logic Programming in a Fragment of Intuitionistic Linear Logic Information and Computation 1994 1102 327365 Naoki Kobayashi and Akinori Yonezawa Asynchronous communication model based on linear logic Formal Aspects of Computing 1994 279294 General introductions edit Baral C Gelfond M 1994 Logic programming and knowledge representation PDF The Journal of Logic Programming 1920 73148 doi 1010160743106694900256 Robert Kowalski The Early Years of Logic Programming Kowalski R A 1988 The early years of logic programming PDF Communications of the ACM 31 3843 doi 1011453504335046 Lloyd J W 1987 Foundations of Logic Programming 2nd edition SpringerVerlag Other sources edit John McCarthy Programs with common sense Symposium on Mechanization of Thought Processes National Physical Laboratory Teddington England 1958 Miller Dale Nadathur Gopalan Pfenning Frank Scedrov Andre 1991 Uniform proofs as a foundation for logic programming Annals of Pure and Applied Logic 51 12 125157 doi 101016016800729190068W Ehud Shapiro Editor Concurrent Prolog MIT Press 1987 James Slagle Experiments with a Deductive QuestionAnswering Program CACM December 1965 Gabbay Dov M Hogger Christopher John Robinson JA eds 19931998 Handbook of Logic in Artificial Intelligence and Logic Programming Vols 15 Oxford University Press Further reading edit Carl Hewitt Procedural Embedding of Knowledge In Planner IJCAI 1971 Carl Hewitt The repeated demise of logic programming and why it will be reincarnated Evgeny Dantsin Thomas Eiter Georg Gottlob Andrei Voronkov Complexity and expressive power of logic programming ACM Comput Surv 333 374425 2001 Ulf Nilsson and Jan Maluszynski Logic Programming and Prolog External links edit Wikimedia Commons has media related to Logic programming Logic Programming Virtual Library entry Bibliographies on Logic Programming Association for Logic Programming ALP Theory and Practice of Logic Programming journal Logic programming in C with Castor Logic programming in Oz Prolog Development Center Racklog Logic Programming in Racket v t e Types of programming languages Actorbased Array Aspectoriented Classbased Concatenative Concurrent Dataflow Declarative Domainspecific Dynamic Esoteric Eventdriven Extensible Functional Imperative Logic Macro Metaprogramming Multiparadigm Objectbased Objectoriented Pipeline Procedural Prototypebased Reflective Rulebased Scripting Stack based Synchronous Tactile Templating Assembly Compiled Interpreted Machine Lowlevel Highlevel Very highlevel First generation Second generation Third generation Fourth generation Fifth generation NonEnglishbased Visual v t e Computable knowledge Topics and concepts Alphabet of human thought Authority control Automated reasoning Commonsense knowledge Commonsense reasoning Computability Formal system Inference engine Knowledge base Knowledgebased systems Knowledge engineering Knowledge extraction Knowledge representation Knowledge retrieval Library classification Logic programming Ontology Personal knowledge base Question answering Semantic reasoner Proposals and implementations Zairja Ars Magna 1300 An Essay towards a Real Character and a Philosophical Language 1688 Calculus ratiocinator and characteristica universalis 1700 Dewey Decimal Classification 1876 Begriffsschrift 1879 Mundaneum 1910 Logical atomism 1918 Tractatus LogicoPhilosophicus 1921 Hilberts program 1920s Incompleteness theorem 1931 World Brain 1938 Memex 1945 General Problem Solver 1959 Prolog 1972 Cyc 1984 Semantic Web 2001 Evi 2007 Wolfram Alpha 2009 Watson 2011 Siri 2011 Knowledge Graph 2012 Wikidata 2012 Cortana 2014 Viv 2016 In fiction The Engine Gullivers Travels 1726 Joe A Logic Named Joe 1946 The Librarian Snow Crash 1992 Dr Know AI Artificial Intelligence 2001 Waterhouse The Baroque Cycle 2003 See also Logic machines in fiction and List of fictional computers Authority control BNE XX550687 BNF cb12067891q data GND 41950963 LCCN sh86003454